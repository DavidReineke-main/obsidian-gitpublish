/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GitPublisherPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var { iterator, toStringTag } = Symbol;
var kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(toStringTag in val) && !(iterator in val);
};
var isEmptyObject = (val) => {
  if (!isObject(val) || isBuffer(val)) {
    return false;
  }
  try {
    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
  } catch (e) {
    return false;
  }
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    if (isBuffer(obj)) {
      return;
    }
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  if (isBuffer(obj)) {
    return null;
  }
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless, skipUndefined } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else if (!skipUndefined || !isUndefined(val)) {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (isBuffer(source)) {
        return source;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var isIterable = (thing) => thing != null && isFunction(thing[iterator]);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isEmptyObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  const msg = error && error.message ? error.message : "Error";
  const errCode = code == null && error ? error.code : code;
  AxiosError.call(axiosError, msg, errCode, config, request, response);
  if (error && axiosError.cause == null) {
    Object.defineProperty(axiosError, "cause", { value: error, configurable: true });
  }
  axiosError.name = error && error.name || "Error";
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2)
    return key;
  return path2.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (utils_default.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path2) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {void}
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...browser_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), {
    visitor: function(value, key, path2, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    },
    ...options
  });
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index) {
    let name = path2[index++];
    if (name === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path2.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path2, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data, this.parseReviver);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils_default.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn(...args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle;

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform_default.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform_default.origin),
  platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
) : () => true;

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path2, domain, secure, sameSite) {
      if (typeof document === "undefined")
        return;
      const cookie = [`${name}=${encodeURIComponent(value)}`];
      if (utils_default.isNumber(expires)) {
        cookie.push(`expires=${new Date(expires).toUTCString()}`);
      }
      if (utils_default.isString(path2)) {
        cookie.push(`path=${path2}`);
      }
      if (utils_default.isString(domain)) {
        cookie.push(`domain=${domain}`);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      if (utils_default.isString(sameSite)) {
        cookie.push(`SameSite=${sameSite}`);
      }
      document.cookie = cookie.join("; ");
    },
    read(name) {
      if (typeof document === "undefined")
        return null;
      const match = document.cookie.match(new RegExp("(?:^|; )" + name + "=([^;]*)"));
      return match ? decodeURIComponent(match[1]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5, "/");
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, prop, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
  };
  utils_default.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if (utils_default.isFunction(data.getHeaders)) {
      const formHeaders = data.getHeaders();
      const allowedHeaders = ["content-type", "content-length"];
      Object.entries(formHeaders).forEach(([key, val]) => {
        if (allowedHeaders.includes(key.toLowerCase())) {
          headers.set(key, val);
        }
      });
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError(event) {
      const msg = event && event.message ? event.message : "Network Error";
      const err = new AxiosError_default(msg, AxiosError_default.ERR_NETWORK, config, request);
      err.event = event || null;
      reject(err);
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default = composeSignals;

// node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
var readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/axios/lib/adapters/fetch.js
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var { isFunction: isFunction2 } = utils_default;
var globalFetchAPI = (({ Request, Response }) => ({
  Request,
  Response
}))(utils_default.global);
var {
  ReadableStream: ReadableStream2,
  TextEncoder
} = utils_default.global;
var test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
var factory = (env) => {
  env = utils_default.merge.call({
    skipUndefined: true
  }, globalFetchAPI, env);
  const { fetch: envFetch, Request, Response } = env;
  const isFetchSupported = envFetch ? isFunction2(envFetch) : typeof fetch === "function";
  const isRequestSupported = isFunction2(Request);
  const isResponseSupported = isFunction2(Response);
  if (!isFetchSupported) {
    return false;
  }
  const isReadableStreamSupported = isFetchSupported && isFunction2(ReadableStream2);
  const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Request(str).arrayBuffer()));
  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform_default.origin, {
      body: new ReadableStream2(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && (() => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
      !resolvers[type] && (resolvers[type] = (res, config) => {
        let method = res && res[type];
        if (method) {
          return method.call(res);
        }
        throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
      });
    });
  })();
  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils_default.isBlob(body)) {
      return body.size;
    }
    if (utils_default.isSpecCompliantForm(body)) {
      const _request = new Request(platform_default.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils_default.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils_default.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length = utils_default.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
  };
  return async (config) => {
    let {
      url,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig_default(config);
    let _fetch = envFetch || fetch;
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request = null;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils_default.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
      const resolvedOptions = {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      };
      request = isRequestSupported && new Request(url, resolvedOptions);
      let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders_default.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config,
          request
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError_default.from(err, err && err.code, config, request);
    }
  };
};
var seedCache = /* @__PURE__ */ new Map();
var getFetch = (config) => {
  let env = config && config.env || {};
  const { fetch: fetch2, Request, Response } = env;
  const seeds = [
    Request,
    Response,
    fetch2
  ];
  let len = seeds.length, i = len, seed, target, map = seedCache;
  while (i--) {
    seed = seeds[i];
    target = map.get(seed);
    target === void 0 && map.set(seed, target = i ? /* @__PURE__ */ new Map() : factory(env));
    map = target;
  }
  return target;
};
var adapter = getFetch();

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default,
  fetch: {
    get: getFetch
  }
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter2) => utils_default.isFunction(adapter2) || adapter2 === null || adapter2 === false;
function getAdapter(adapters, config) {
  adapters = utils_default.isArray(adapters) ? adapters : [adapters];
  const { length } = adapters;
  let nameOrAdapter;
  let adapter2;
  const rejectedReasons = {};
  for (let i = 0; i < length; i++) {
    nameOrAdapter = adapters[i];
    let id;
    adapter2 = nameOrAdapter;
    if (!isResolvedHandle(nameOrAdapter)) {
      adapter2 = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
      if (adapter2 === void 0) {
        throw new AxiosError_default(`Unknown adapter '${id}'`);
      }
    }
    if (adapter2 && (utils_default.isFunction(adapter2) || (adapter2 = adapter2.get(config)))) {
      break;
    }
    rejectedReasons[id || "#" + i] = adapter2;
  }
  if (!adapter2) {
    const reasons = Object.entries(rejectedReasons).map(
      ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
    );
    let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
    throw new AxiosError_default(
      `There is no suitable adapter to dispatch the request ` + s,
      "ERR_NOT_SUPPORT"
    );
  }
  return adapter2;
}
var adapters_default = {
  /**
   * Resolve an adapter from a list of adapter names or functions.
   * @type {Function}
   */
  getAdapter,
  /**
   * Exposes all known adapters
   * @type {Object<string, Function|Object>}
   */
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter2 = adapters_default.getAdapter(config.adapter || defaults_default.adapter, config);
  return adapter2(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/env/data.js
var VERSION = "1.13.2";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== void 0) {
    } else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator_default.assertOptions(config, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift(...requestInterceptorChain);
      chain.push(...responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
  WebServerIsDown: 521,
  ConnectionTimedOut: 522,
  OriginIsUnreachable: 523,
  TimeoutOccurred: 524,
  SslHandshakeFailed: 525,
  InvalidSslCertificate: 526
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter: getAdapter2,
  mergeConfig: mergeConfig2
} = axios_default;

// main.ts
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));
var GitPublisherPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.pendingChanges = /* @__PURE__ */ new Map();
    this.inactivityHandle = null;
    this.sessionHandle = null;
    this.sessionStart = null;
    this.lastActivityTime = null;
    this.publishingInProgress = false;
    this.publishQueue = /* @__PURE__ */ new Set();
    this.shaMap = {};
    this.publishedStatusEl = null;
    this.publishedCheckbox = null;
    this.publishedTrack = null;
    this.debounceHandle = null;
    this.logPath = null;
    this.lastScanSummary = null;
  }
  async loadSettings() {
    const raw = await this.loadData();
    const defaults2 = { repoUri: "", githubToken: "", autoPublishEnabled: true, inactivityDelaySec: 30, maxIntervalMin: 5, defaultBranch: "main", debounceMs: 1500, batchCommitMessage: "Publish", maxFileSizeKB: 1024 };
    if (raw && raw.settings) {
      this.settings = Object.assign({}, defaults2, raw.settings);
      this.shaMap = raw.shaMap || {};
    } else {
      this.settings = Object.assign({}, defaults2, raw || {});
      this.shaMap = {};
    }
    this.sanitizeSettings();
  }
  async saveSettings() {
    await this.saveData({ settings: this.settings, shaMap: this.shaMap });
  }
  sanitizeSettings() {
    if (!/^https:\/\/github\.com\/[\w.-]+\/[\w.-]+(?:\.git)?$/.test(this.settings.repoUri || "")) {
      this.settings.repoUri = "";
      this.settings.autoPublishEnabled = false;
    }
    if (!/^[A-Za-z0-9._\/-]+$/.test(this.settings.defaultBranch))
      this.settings.defaultBranch = "main";
    if (this.settings.inactivityDelaySec < 5)
      this.settings.inactivityDelaySec = 5;
    if (this.settings.maxIntervalMin < 1)
      this.settings.maxIntervalMin = 1;
    if (this.settings.debounceMs < 250)
      this.settings.debounceMs = 250;
    if (this.settings.maxFileSizeKB < 50)
      this.settings.maxFileSizeKB = 50;
    this.settings.batchCommitMessage = this.settings.batchCommitMessage.replace(/[\r\n]/g, " ").slice(0, 100) || "Publish";
  }
  toBase64(str) {
    return Buffer.from(str, "utf8").toString("base64");
  }
  async githubReq(method, url, data) {
    var _a, _b;
    try {
      const r = await axios_default.request({ method, url, data, headers: { Authorization: `Bearer ${this.settings.githubToken}`, Accept: "application/vnd.github.v3+json" } });
      this.log("github_ok", { method, url, status: r.status });
      return r.data;
    } catch (e) {
      const s = (_a = e.response) == null ? void 0 : _a.status;
      this.log("github_err", { method, url, status: s, body: (_b = e.response) == null ? void 0 : _b.data }, s === 409 ? "WARN" : "ERROR");
      if (s === 409)
        new import_obsidian.Notice("GitHub 409 Konflikt");
      else
        new import_obsidian.Notice(`GitHub Fehler ${s || ""}`);
      return null;
    }
  }
  githubGet(url) {
    return this.githubReq("get", url);
  }
  githubPost(url, data) {
    return this.githubReq("post", url, data);
  }
  githubPatch(url, data) {
    return this.githubReq("patch", url, data);
  }
  githubDelete(url, data) {
    return this.githubReq("delete", url, data);
  }
  githubPut(url, data) {
    return this.githubReq("put", url, data);
  }
  ensureGitHubConfig() {
    return !!(this.settings.repoUri && this.settings.githubToken);
  }
  async onload() {
    await this.loadSettings();
    this.initLogging();
    this.registerView("gitpublish-pending-view", (leaf) => new PendingView(leaf, this));
    this.addRibbonIcon("upload-cloud", "Git Publish", () => this.activateView());
    this.createPublishedToggle();
    this.addCommands();
    this.registerEvents();
    this.addSettingTab(new GitPublisherSettingTab(this.app, this));
    this.refreshPublishedStatus();
    await this.initialRepoScan();
  }
  onunload() {
    this.clearTimers();
    this.app.workspace.getLeavesOfType("gitpublish-pending-view").forEach((l) => l.detach());
  }
  addCommands() {
    this.addCommand({ id: "gitpub-toggle-published", name: "Toggle published flag", checkCallback: (c) => {
      const f = this.app.workspace.getActiveFile();
      if (!f)
        return false;
      if (!c)
        this.togglePublished(f);
      return true;
    } });
    this.addCommand({ id: "gitpub-publish-current", name: "Publish current file now", checkCallback: (c) => {
      const f = this.app.workspace.getActiveFile();
      if (!f)
        return false;
      if (!c)
        this.queueFileForPublish(f);
      return true;
    } });
    this.addCommand({ id: "gitpub-publish-all", name: "Publish all pending now", callback: async () => {
      await this.publishAllPending();
    } });
    this.addCommand({ id: "gitpub-rescan", name: "Rescan published files", callback: async () => {
      const p = this.parseRepo();
      if (!p) {
        new import_obsidian.Notice("Repo ung\xFCltig");
        return;
      }
      await this.scanPublishedFiles(p.owner, p.repo);
      this.updatePendingView();
      new import_obsidian.Notice("Rescan fertig");
    } });
    this.addCommand({ id: "gitpub-show-help", name: "Show Git Publisher Hilfe", callback: () => new HelpModal(this.app).open() });
    this.addCommand({ id: "gitpub-add-published-property", name: "Add published property to current file", checkCallback: (c) => {
      const f = this.app.workspace.getActiveFile();
      if (!f)
        return false;
      if (!c)
        this.ensurePublishedProperty(f, false);
      return true;
    } });
  }
  registerEvents() {
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => {
      this.refreshPublishedStatus();
      this.updatePendingView();
    }));
    this.registerEvent(this.app.metadataCache.on("changed", (file) => {
      const a = this.app.workspace.getActiveFile();
      if (a && file.path === a.path)
        this.refreshPublishedStatus();
      this.updatePendingView();
    }));
    this.registerEvent(this.app.workspace.on("editor-change", () => {
      const f = this.app.workspace.getActiveFile();
      if (f)
        this.handleEditorActivity(f);
    }));
    this.registerEvent(this.app.vault.on("modify", (file) => {
      var _a;
      if (!(file instanceof import_obsidian.TFile) || file.extension !== "md")
        return;
      const c = this.app.metadataCache.getFileCache(file);
      if (((_a = c == null ? void 0 : c.frontmatter) == null ? void 0 : _a.published) === true) {
        this.pendingChanges.set(file.path, true);
        this.refreshPublishedStatus();
        this.updatePendingView();
      }
    }));
  }
  activateView() {
    const leaves = this.app.workspace.getLeavesOfType("gitpublish-pending-view");
    if (leaves.length === 0) {
      const rl = this.app.workspace.getRightLeaf(false);
      if (rl)
        rl.setViewState({ type: "gitpublish-pending-view", active: true });
    } else
      this.app.workspace.revealLeaf(leaves[0]);
  }
  clearTimers() {
    if (this.inactivityHandle)
      clearTimeout(this.inactivityHandle);
    if (this.sessionHandle)
      clearTimeout(this.sessionHandle);
    if (this.debounceHandle)
      clearTimeout(this.debounceHandle);
    this.inactivityHandle = this.sessionHandle = this.sessionStart = this.debounceHandle = null;
  }
  createPublishedToggle() {
    this.publishedStatusEl = this.addStatusBarItem();
    this.publishedStatusEl.addClass("gitpublish-status");
    this.publishedStatusEl.createSpan({ text: "Published" }).addClass("gitpublish-status-label");
    const w = this.publishedStatusEl.createSpan({ cls: "gitpublish-toggle-wrapper" });
    const input = document.createElement("input");
    input.type = "checkbox";
    input.className = "gitpublish-toggle-input";
    w.appendChild(input);
    this.publishedCheckbox = input;
    const track = document.createElement("span");
    track.className = "gitpublish-toggle-track";
    track.tabIndex = 0;
    const knob = document.createElement("span");
    knob.className = "gitpublish-toggle-knob";
    track.appendChild(knob);
    w.appendChild(track);
    this.publishedTrack = track;
    const act = async () => {
      if (input.disabled)
        return;
      const f = this.app.workspace.getActiveFile();
      if (!f)
        return;
      await this.setPublished(f, !input.checked);
    };
    track.addEventListener("click", act);
    track.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        act();
      }
    });
  }
  handleEditorActivity(file) {
    if (!this.settings.autoPublishEnabled)
      return;
    this.lastActivityTime = Date.now();
    if (!this.sessionStart) {
      this.sessionStart = Date.now();
      this.resetSessionTimer();
    }
    this.resetInactivityTimer(file);
    this.resetDebounce();
  }
  resetDebounce() {
    if (this.debounceHandle)
      clearTimeout(this.debounceHandle);
    this.debounceHandle = window.setTimeout(() => {
    }, this.settings.debounceMs);
  }
  resetInactivityTimer(file) {
    if (this.inactivityHandle)
      clearTimeout(this.inactivityHandle);
    this.inactivityHandle = window.setTimeout(async () => {
      await this.publishFileIfPending(file);
      this.refreshPublishedStatus();
    }, this.settings.inactivityDelaySec * 1e3);
  }
  resetSessionTimer() {
    if (this.sessionHandle)
      clearTimeout(this.sessionHandle);
    this.sessionHandle = window.setTimeout(async () => {
      await this.publishAllPending();
      this.clearTimers();
      this.refreshPublishedStatus();
    }, this.settings.maxIntervalMin * 60 * 1e3);
  }
  async publishFileIfPending(file) {
    var _a;
    if (!this.settings.autoPublishEnabled)
      return;
    const c = this.app.metadataCache.getFileCache(file);
    if (((_a = c == null ? void 0 : c.frontmatter) == null ? void 0 : _a.published) !== true)
      return;
    if (!this.pendingChanges.get(file.path))
      return;
    await this.queueFileForPublish(file);
  }
  async publishAllPending() {
    if (!this.settings.autoPublishEnabled)
      return;
    for (const [p, pen] of this.pendingChanges.entries()) {
      if (!pen)
        continue;
      const f = this.app.vault.getAbstractFileByPath(p);
      if (f instanceof import_obsidian.TFile)
        await this.queueFileForPublish(f);
    }
  }
  async queueFileForPublish(file) {
    if (!this.isSafePath(file.path))
      return;
    if (await this.isTooLarge(file)) {
      this.log("skip_large", { path: file.path });
      return;
    }
    this.publishQueue.add(file.path);
    await this.processPublishQueue();
  }
  async isTooLarge(file) {
    var _a, _b;
    const stat = (_b = (_a = this.app.vault.adapter).stat) == null ? void 0 : _b.call(_a, file.path);
    if (stat == null ? void 0 : stat.size)
      return stat.size > this.settings.maxFileSizeKB * 1024;
    const content = await this.app.vault.read(file);
    return content.length > this.settings.maxFileSizeKB * 1024;
  }
  isSafePath(p) {
    return !p.startsWith(".") && !p.includes("..");
  }
  async processPublishQueue() {
    if (this.publishingInProgress)
      return;
    if (!this.ensureGitHubConfig())
      return;
    this.publishingInProgress = true;
    try {
      const paths = [...this.publishQueue];
      if (paths.length === 0)
        return;
      await this.publishBatch(paths);
      paths.forEach((p) => this.publishQueue.delete(p));
    } finally {
      this.publishingInProgress = false;
      this.refreshPublishedStatus();
      this.updatePendingView();
    }
  }
  parseRepo() {
    const u = this.settings.repoUri;
    if (!u)
      return null;
    const m = u.match(/^https:\/\/github\.com\/([\w.-]+)\/([\w.-]+)(?:\.git)?$/);
    return m ? { owner: m[1], repo: m[2] } : null;
  }
  async fetchContentsSha(owner, repo, p) {
    const r = await this.githubGet(`https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(p)}?ref=${this.settings.defaultBranch}`);
    return (r == null ? void 0 : r.sha) || null;
  }
  async ensureBranchExists(owner, repo) {
    var _a, _b;
    const refUrl = `https://api.github.com/repos/${owner}/${repo}/git/ref/heads/${this.settings.defaultBranch}`;
    const ref = await this.githubGet(refUrl);
    if ((_a = ref == null ? void 0 : ref.object) == null ? void 0 : _a.sha)
      return ref.object.sha;
    const ok = await this.initializeBranch(owner, repo);
    if (!ok)
      return null;
    const ref2 = await this.githubGet(refUrl);
    return ((_b = ref2 == null ? void 0 : ref2.object) == null ? void 0 : _b.sha) || null;
  }
  async initializeBranch(owner, repo) {
    var _a;
    try {
      const pathName = ".gitkeep";
      const res = await this.githubPut(`https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(pathName)}`, { message: "Initialize branch", content: this.toBase64("init"), branch: this.settings.defaultBranch });
      return !!((_a = res == null ? void 0 : res.content) == null ? void 0 : _a.sha);
    } catch (e) {
      return false;
    }
  }
  async publishBatch(paths) {
    this.log("batch_start", { count: paths.length });
    const pr = this.parseRepo();
    if (!pr) {
      this.log("batch_abort_parse");
      return;
    }
    const { owner, repo } = pr;
    const baseSha = await this.ensureBranchExists(owner, repo);
    if (!baseSha) {
      this.log("batch_abort_branch");
      return;
    }
    const blobs = [];
    for (const p of paths) {
      const f = this.app.vault.getAbstractFileByPath(p);
      if (!(f instanceof import_obsidian.TFile)) {
        this.log("skip_not_file", { path: p });
        continue;
      }
      const content = await this.app.vault.read(f);
      const blob = await this.githubPost(`https://api.github.com/repos/${owner}/${repo}/git/blobs`, { content, encoding: "utf-8" });
      if (blob == null ? void 0 : blob.sha)
        blobs.push({ path: p, mode: "100644", type: "blob", sha: blob.sha });
      else
        this.log("blob_fail", { path: p });
    }
    if (!blobs.length) {
      this.log("batch_no_blobs");
      return;
    }
    const tree = await this.githubPost(`https://api.github.com/repos/${owner}/${repo}/git/trees`, { base_tree: baseSha, tree: blobs });
    if (!(tree == null ? void 0 : tree.sha)) {
      this.log("tree_fail");
      return;
    }
    const msg = `${this.settings.batchCommitMessage} (${new Date().toISOString()})`;
    const commit = await this.githubPost(`https://api.github.com/repos/${owner}/${repo}/git/commits`, { message: msg, tree: tree.sha, parents: [baseSha] });
    if (!(commit == null ? void 0 : commit.sha)) {
      this.log("commit_fail");
      return;
    }
    const updated = await this.githubPatch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${this.settings.defaultBranch}`, { sha: commit.sha, force: false });
    if (updated) {
      for (const p of paths)
        this.pendingChanges.set(p, false);
      await this.saveSettings();
      this.log("batch_ok", { commit: commit.sha, files: paths.length });
      new import_obsidian.Notice(`Published ${paths.length} Dateien`);
    } else
      this.log("ref_fail");
  }
  async deleteFileFromRepo(file) {
    const pr = this.parseRepo();
    if (!pr)
      return;
    const { owner, repo } = pr;
    const sha = await this.fetchContentsSha(owner, repo, file.path);
    if (!sha) {
      this.log("delete_missing_remote", { path: file.path });
      return;
    }
    const res = await this.githubDelete(`https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(file.path)}`, { message: `Unpublish ${file.path}`, branch: this.settings.defaultBranch, sha });
    if (res) {
      this.pendingChanges.delete(file.path);
      this.log("deleted", { path: file.path });
    }
  }
  async togglePublished(file) {
    const cur = await this.getPublished(file);
    await this.setPublished(file, !cur);
  }
  async setPublished(file, value) {
    await this.app.fileManager.processFrontMatter(file, (fm) => {
      fm.published = value;
    });
    if (value) {
      new import_obsidian.Notice(`${file.basename} published`);
      this.pendingChanges.set(file.path, true);
      this.log("flag_on", { path: file.path });
    } else {
      new import_obsidian.Notice(`${file.basename} unpublished`);
      await this.deleteFileFromRepo(file);
      this.log("flag_off", { path: file.path });
    }
    setTimeout(() => {
      this.refreshPublishedStatus();
      this.updatePendingView();
    }, 150);
  }
  async ensurePublishedProperty(file, silent = false) {
    const c = this.app.metadataCache.getFileCache(file);
    const has = (c == null ? void 0 : c.frontmatter) && Object.prototype.hasOwnProperty.call(c.frontmatter, "published");
    if (has) {
      if (!silent)
        new import_obsidian.Notice("published existiert");
      return false;
    }
    await this.app.fileManager.processFrontMatter(file, (fm) => {
      fm.published = false;
    });
    if (!silent)
      new import_obsidian.Notice("published hinzugef\xFCgt");
    setTimeout(() => {
      this.refreshPublishedStatus();
      this.updatePendingView();
    }, 120);
    return true;
  }
  async getPublished(file) {
    var _a;
    const c = this.app.metadataCache.getFileCache(file);
    return ((_a = c == null ? void 0 : c.frontmatter) == null ? void 0 : _a.published) === true;
  }
  refreshPublishedStatus() {
    var _a;
    if (!this.publishedCheckbox || !this.publishedTrack)
      return;
    const f = this.app.workspace.getActiveFile();
    if (!f) {
      this.publishedCheckbox.checked = false;
      this.publishedCheckbox.disabled = true;
      this.publishedTrack.classList.remove("is-on");
      this.publishedTrack.classList.add("is-disabled");
      this.publishedTrack.classList.remove("has-pending");
      return;
    }
    this.publishedCheckbox.disabled = false;
    const c = this.app.metadataCache.getFileCache(f);
    const val = ((_a = c == null ? void 0 : c.frontmatter) == null ? void 0 : _a.published) === true;
    this.publishedCheckbox.checked = val;
    this.publishedTrack.classList.toggle("is-on", val);
    this.publishedTrack.classList.remove("is-disabled");
    const pen = this.pendingChanges.get(f.path);
    this.publishedTrack.classList.toggle("has-pending", !!pen && val);
  }
  updatePendingView() {
    for (const leaf of this.app.workspace.getLeavesOfType("gitpublish-pending-view")) {
      const v = leaf.view;
      if (v instanceof PendingView)
        v.render();
    }
  }
  initLogging() {
    var _a, _b;
    try {
      const base = ((_b = (_a = this.app.vault.adapter) == null ? void 0 : _a.getBasePath) == null ? void 0 : _b.call(_a)) || "";
      if (base) {
        this.logPath = path.join(base, ".obsidian", "plugins", "obsidian-gitpublish", "gitpublish-log.ndjson");
        this.ensureLogFile();
        this.log("logger_init", { path: this.logPath });
      }
    } catch (e) {
      this.logPath = null;
    }
  }
  ensureLogFile() {
    if (!this.logPath)
      return;
    try {
      if (!fs.existsSync(this.logPath))
        fs.writeFileSync(this.logPath, "");
      const s = fs.statSync(this.logPath);
      if (s.size > 1e6) {
        const rot = this.logPath + ".1";
        try {
          fs.renameSync(this.logPath, rot);
        } catch (e) {
        }
        fs.writeFileSync(this.logPath, "");
        this.log("log_rotate", { old: rot });
      }
    } catch (e) {
    }
  }
  log(msg, meta = {}, level = "INFO") {
    if (!this.logPath)
      return;
    const entry = { ts: new Date().toISOString(), level, msg, ...meta };
    try {
      fs.appendFileSync(this.logPath, JSON.stringify(entry) + "\n");
    } catch (e) {
    }
  }
  async initialRepoScan() {
    if (!this.ensureGitHubConfig())
      return;
    const pr = this.parseRepo();
    if (!pr)
      return;
    const repoInfo = await this.githubGet(`https://api.github.com/repos/${pr.owner}/${pr.repo}`);
    if (!repoInfo)
      return;
    const baseSha = await this.ensureBranchExists(pr.owner, pr.repo);
    if (!baseSha)
      return;
    await this.scanPublishedFiles(pr.owner, pr.repo);
    this.updatePendingView();
  }
  async scanPublishedFiles(owner, repo) {
    var _a;
    const files = this.app.vault.getMarkdownFiles();
    let total = 0, outOfSync = 0, missing = 0;
    for (const f of files) {
      const c = this.app.metadataCache.getFileCache(f);
      if (((_a = c == null ? void 0 : c.frontmatter) == null ? void 0 : _a.published) !== true)
        continue;
      total++;
      const remote = await this.githubGet(`https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(f.path)}?ref=${this.settings.defaultBranch}`);
      if (!remote || !remote.content) {
        this.pendingChanges.set(f.path, true);
        missing++;
        continue;
      }
      const local = await this.app.vault.read(f);
      const localB64 = this.toBase64(local);
      const remoteB64 = remote.content.replace(/\n/g, "");
      if (localB64 !== remoteB64) {
        this.pendingChanges.set(f.path, true);
        outOfSync++;
      } else {
        this.pendingChanges.set(f.path, false);
        this.shaMap[f.path] = remote.sha;
      }
    }
    this.lastScanSummary = { total, outOfSync, missing, ts: Date.now() };
    this.log("scan_done", this.lastScanSummary);
  }
};
var GitPublisherSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Git Publisher Einstellungen" });
    containerEl.createEl("p", { text: "Dieses Plugin ver\xF6ffentlicht Markdown-Dateien mit Frontmatter published:true automatisiert auf ein GitHub Repository." });
    containerEl.createEl("p", { text: "Ablauf: Wenn du tippst starten Timer. Inaktivit\xE4t l\xF6st Einzel-Publish aus, sp\xE4testens nach Session-Intervall werden alle pending Dateien im Batch \xFCbertragen." });
    containerEl.createEl("p", { text: "Toggle unten rechts zeigt Status (gr\xFCn=published, blau=pending \xC4nderungen). Unpublished entfernt Datei aus Repo." });
    new import_obsidian.Setting(containerEl).setName("GitHub Repo URL").setDesc("Format: https://github.com/OWNER/REPO oder mit .git").addText((t) => t.setPlaceholder("https://github.com/user/repo").setValue(this.plugin.settings.repoUri).onChange(async (v) => {
      this.plugin.settings.repoUri = v.trim();
      this.plugin.sanitizeSettings();
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("GitHub Token").setDesc("Fine-grained Token: Contents Read/Write").addText((t) => {
      t.inputEl.type = "password";
      t.setPlaceholder("ghp_...").setValue(this.plugin.settings.githubToken).onChange(async (v) => {
        this.plugin.settings.githubToken = v.trim();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Auto Publish").setDesc("Schaltet den automatischen Mechanismus an/aus").addToggle((t) => t.setValue(this.plugin.settings.autoPublishEnabled).onChange(async (v) => {
      this.plugin.settings.autoPublishEnabled = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Inaktivit\xE4ts-Sekunden").setDesc("Zeit ohne Tipp bis Einzel-Publish").addText((t) => t.setValue(String(this.plugin.settings.inactivityDelaySec)).onChange(async (v) => {
      const n = parseInt(v, 10);
      if (!isNaN(n) && n >= 5)
        this.plugin.settings.inactivityDelaySec = n;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Session-Minuten").setDesc("Max Zeit bis Batch-Publish").addText((t) => t.setValue(String(this.plugin.settings.maxIntervalMin)).onChange(async (v) => {
      const n = parseInt(v, 10);
      if (!isNaN(n) && n >= 1)
        this.plugin.settings.maxIntervalMin = n;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Debounce (ms)").setDesc("Eingabe-Entprellung").addText((t) => t.setValue(String(this.plugin.settings.debounceMs)).onChange(async (v) => {
      const n = parseInt(v, 10);
      if (!isNaN(n) && n >= 250)
        this.plugin.settings.debounceMs = n;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Batch Commit Message").setDesc("Prefix f\xFCr Commits").addText((t) => t.setValue(this.plugin.settings.batchCommitMessage).onChange(async (v) => {
      this.plugin.settings.batchCommitMessage = v.trim();
      this.plugin.sanitizeSettings();
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Branch").setDesc("Zielbranch").addText((t) => t.setValue(this.plugin.settings.defaultBranch).onChange(async (v) => {
      if (v.trim())
        this.plugin.settings.defaultBranch = v.trim();
      this.plugin.sanitizeSettings();
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Max Dateigr\xF6\xDFe (KB)").setDesc("\xDCberschreitet eine Datei diesen Wert wird sie nicht ver\xF6ffentlicht").addText((t) => t.setValue(String(this.plugin.settings.maxFileSizeKB)).onChange(async (v) => {
      const n = parseInt(v, 10);
      if (!isNaN(n) && n >= 50)
        this.plugin.settings.maxFileSizeKB = n;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Sicherheit" });
    containerEl.createEl("ul", { text: "" }).appendChild(this.buildBullet("Token wird nie geloggt."));
    containerEl.createEl("ul", { text: "" }).appendChild(this.buildBullet("Pfadvalidierung verhindert ../ Traversal."));
    containerEl.createEl("ul", { text: "" }).appendChild(this.buildBullet("Gr\xF6\xDFenlimit sch\xFCtzt vor gro\xDFen Commits."));
    containerEl.createEl("h3", { text: "Nutzungsschritte" });
    containerEl.createEl("ol", { text: "" }).appendChild(this.buildBullet("Repo URL & Token setzen."));
    containerEl.createEl("ol", { text: "" }).appendChild(this.buildBullet("In Frontmatter published:true hinzuf\xFCgen."));
    containerEl.createEl("ol", { text: "" }).appendChild(this.buildBullet("Schreiben \u2013 Timer ver\xF6ffentlichen automatisch."));
    containerEl.createEl("ol", { text: "" }).appendChild(this.buildBullet("View nutzen f\xFCr \xDCberblick & manuellen Publish."));
  }
  buildBullet(text) {
    const li = document.createElement("li");
    li.textContent = text;
    return li;
  }
};
var PendingView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return "gitpublish-pending-view";
  }
  getDisplayText() {
    return "Git Publish";
  }
  getIcon() {
    return "upload-cloud";
  }
  async onOpen() {
    this.render();
  }
  async onClose() {
  }
  render() {
    const el = this.containerEl;
    el.empty();
    el.addClass("gitpublish-view");
    el.createEl("h3", { text: "Pending Changes" });
    if (!this.plugin.ensureGitHubConfig()) {
      el.createEl("div", { text: "Konfiguration fehlt (Repo / Token)." });
      return;
    }
    const list = el.createDiv({ cls: "gitpublish-pending-list" });
    let count = 0;
    for (const [p, pen] of this.plugin.pendingChanges.entries()) {
      if (!pen)
        continue;
      count++;
      const row = list.createDiv({ cls: "gitpublish-row" });
      row.createSpan({ text: p });
      const btn = row.createEl("button", { text: "Publish" });
      btn.onclick = async () => {
        const f = this.plugin.app.vault.getAbstractFileByPath(p);
        if (f instanceof import_obsidian.TFile) {
          await this.plugin.queueFileForPublish(f);
          this.render();
        }
      };
    }
    if (count === 0)
      list.createDiv({ text: "Keine pending Dateien." });
    const actions = el.createDiv({ cls: "gitpublish-actions" });
    const allBtn = actions.createEl("button", { text: "Alle publishen" });
    allBtn.onclick = async () => {
      await this.plugin.publishAllPending();
      this.render();
    };
    const timers = el.createDiv({ cls: "gitpublish-timers" });
    const now = Date.now();
    let inactLeft = 0;
    if (this.plugin.inactivityHandle && this.plugin.lastActivityTime) {
      const elapsed = now - this.plugin.lastActivityTime;
      inactLeft = Math.max(0, Math.round((this.plugin.settings.inactivityDelaySec * 1e3 - elapsed) / 1e3));
    }
    let sessLeft = 0;
    if (this.plugin.sessionHandle && this.plugin.sessionStart) {
      const elapsedS = now - this.plugin.sessionStart;
      sessLeft = Math.max(0, Math.round((this.plugin.settings.maxIntervalMin * 60 * 1e3 - elapsedS) / 1e3));
    }
    const stat = timers.createDiv({ cls: "gitpublish-timers-line" });
    stat.createDiv({ text: `Session Rest: ${sessLeft}s` });
    stat.createDiv({ text: `Inaktivit\xE4t Rest: ${inactLeft}s` });
    if (this.plugin["lastScanSummary"]) {
      const s = this.plugin["lastScanSummary"];
      el.createDiv({ cls: "gitpublish-scan-summary", text: `Scan: ${s.total} published, ${s.missing} fehlen, ${s.outOfSync} abweichend (${new Date(s.ts).toLocaleTimeString()})` });
    }
  }
};
var HelpModal = class extends import_obsidian.Modal {
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Git Publisher Hilfe" });
    contentEl.createEl("p", { text: "Markiere Dateien mit Frontmatter published:true um sie automatisch zu ver\xF6ffentlichen." });
    contentEl.createEl("p", { text: "Timers: Inaktivit\xE4t ver\xF6ffentlicht ein einzelnes File, Session ver\xF6ffentlicht alle pending Dateien im Batch." });
    contentEl.createEl("p", { text: "Toggle unten rechts: Gr\xFCn = synchron, Blau = pending \xC4nderungen, Rot = deaktiviert." });
    contentEl.createEl("p", { text: "Unpublish (published:false) l\xF6scht Datei aus dem Repo." });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvc0Vycm9yLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9udWxsLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy90b0Zvcm1EYXRhLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9BeGlvc1VSTFNlYXJjaFBhcmFtcy5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2Jyb3dzZXIvY2xhc3Nlcy9VUkxTZWFyY2hQYXJhbXMuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9icm93c2VyL2NsYXNzZXMvRm9ybURhdGEuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9icm93c2VyL2NsYXNzZXMvQmxvYi5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2Jyb3dzZXIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9jb21tb24vdXRpbHMuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdG9VUkxFbmNvZGVkRm9ybS5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvZm9ybURhdGFUb0pTT04uanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvc0hlYWRlcnMuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZVByb3RvY29sLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcGVlZG9tZXRlci5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdGhyb3R0bGUuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3Byb2dyZXNzRXZlbnRSZWR1Y2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9tZXJnZUNvbmZpZy5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcmVzb2x2ZUNvbmZpZy5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tcG9zZVNpZ25hbHMuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3RyYWNrU3RyZWFtLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMvZmV0Y2guanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy9hZGFwdGVycy5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvZW52L2RhdGEuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3ZhbGlkYXRvci5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9IdHRwU3RhdHVzQ29kZS5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgQXBwLCBQbHVnaW4sIE5vdGljZSwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgVEZpbGUsIFdvcmtzcGFjZUxlYWYsIEl0ZW1WaWV3LCBNb2RhbCB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbnRlcmZhY2UgR2l0UHVibGlzaGVyU2V0dGluZ3MgeyByZXBvVXJpOiBzdHJpbmc7IGdpdGh1YlRva2VuOiBzdHJpbmc7IGF1dG9QdWJsaXNoRW5hYmxlZDogYm9vbGVhbjsgaW5hY3Rpdml0eURlbGF5U2VjOiBudW1iZXI7IG1heEludGVydmFsTWluOiBudW1iZXI7IGRlZmF1bHRCcmFuY2g6IHN0cmluZzsgZGVib3VuY2VNczogbnVtYmVyOyBiYXRjaENvbW1pdE1lc3NhZ2U6IHN0cmluZzsgbWF4RmlsZVNpemVLQjogbnVtYmVyOyB9XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdpdFB1Ymxpc2hlclBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG5cdHB1YmxpYyBzZXR0aW5nczogR2l0UHVibGlzaGVyU2V0dGluZ3M7XG5cdHB1YmxpYyBwZW5kaW5nQ2hhbmdlczogTWFwPHN0cmluZywgYm9vbGVhbj4gPSBuZXcgTWFwKCk7XG5cdHB1YmxpYyBpbmFjdGl2aXR5SGFuZGxlOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblx0cHVibGljIHNlc3Npb25IYW5kbGU6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXHRwdWJsaWMgc2Vzc2lvblN0YXJ0OiBudW1iZXIgfCBudWxsID0gbnVsbDtcblx0cHVibGljIGxhc3RBY3Rpdml0eVRpbWU6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXHRwdWJsaWMgcHVibGlzaGluZ0luUHJvZ3Jlc3MgPSBmYWxzZTtcblx0cHVibGljIHB1Ymxpc2hRdWV1ZTogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG5cdHByaXZhdGUgc2hhTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cdHByaXZhdGUgcHVibGlzaGVkU3RhdHVzRWw6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgcHVibGlzaGVkQ2hlY2tib3g6IEhUTUxJbnB1dEVsZW1lbnQgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBwdWJsaXNoZWRUcmFjazogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcblx0cHJpdmF0ZSBkZWJvdW5jZUhhbmRsZTogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgbG9nUGF0aDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgbGFzdFNjYW5TdW1tYXJ5OiB7IHRvdGFsOiBudW1iZXI7IG91dE9mU3luYzogbnVtYmVyOyBtaXNzaW5nOiBudW1iZXI7IHRzOiBudW1iZXIgfSB8IG51bGwgPSBudWxsO1xuXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcblx0XHRjb25zdCByYXc6IGFueSA9IGF3YWl0IHRoaXMubG9hZERhdGEoKTtcblx0XHRjb25zdCBkZWZhdWx0czogR2l0UHVibGlzaGVyU2V0dGluZ3MgPSB7IHJlcG9Vcmk6ICcnLCBnaXRodWJUb2tlbjogJycsIGF1dG9QdWJsaXNoRW5hYmxlZDogdHJ1ZSwgaW5hY3Rpdml0eURlbGF5U2VjOiAzMCwgbWF4SW50ZXJ2YWxNaW46IDUsIGRlZmF1bHRCcmFuY2g6ICdtYWluJywgZGVib3VuY2VNczogMTUwMCwgYmF0Y2hDb21taXRNZXNzYWdlOiAnUHVibGlzaCcsIG1heEZpbGVTaXplS0I6IDEwMjQgfTtcblx0XHRpZiAocmF3ICYmIHJhdy5zZXR0aW5ncykgeyB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIHJhdy5zZXR0aW5ncyk7IHRoaXMuc2hhTWFwID0gcmF3LnNoYU1hcCB8fCB7fTsgfSBlbHNlIHsgdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCByYXcgfHwge30pOyB0aGlzLnNoYU1hcCA9IHt9OyB9XG5cdFx0dGhpcy5zYW5pdGl6ZVNldHRpbmdzKCk7XG5cdH1cblx0YXN5bmMgc2F2ZVNldHRpbmdzKCkgeyBhd2FpdCB0aGlzLnNhdmVEYXRhKHsgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsIHNoYU1hcDogdGhpcy5zaGFNYXAgfSk7IH1cblxuXHRwdWJsaWMgc2FuaXRpemVTZXR0aW5ncygpIHtcblx0XHRpZiAoIS9eaHR0cHM6XFwvXFwvZ2l0aHViXFwuY29tXFwvW1xcdy4tXStcXC9bXFx3Li1dKyg/OlxcLmdpdCk/JC8udGVzdCh0aGlzLnNldHRpbmdzLnJlcG9VcmkgfHwgJycpKSB7IHRoaXMuc2V0dGluZ3MucmVwb1VyaSA9ICcnOyB0aGlzLnNldHRpbmdzLmF1dG9QdWJsaXNoRW5hYmxlZCA9IGZhbHNlOyB9XG5cdFx0aWYgKCEvXltBLVphLXowLTkuX1xcLy1dKyQvLnRlc3QodGhpcy5zZXR0aW5ncy5kZWZhdWx0QnJhbmNoKSkgdGhpcy5zZXR0aW5ncy5kZWZhdWx0QnJhbmNoID0gJ21haW4nO1xuXHRcdGlmICh0aGlzLnNldHRpbmdzLmluYWN0aXZpdHlEZWxheVNlYyA8IDUpIHRoaXMuc2V0dGluZ3MuaW5hY3Rpdml0eURlbGF5U2VjID0gNTtcblx0XHRpZiAodGhpcy5zZXR0aW5ncy5tYXhJbnRlcnZhbE1pbiA8IDEpIHRoaXMuc2V0dGluZ3MubWF4SW50ZXJ2YWxNaW4gPSAxO1xuXHRcdGlmICh0aGlzLnNldHRpbmdzLmRlYm91bmNlTXMgPCAyNTApIHRoaXMuc2V0dGluZ3MuZGVib3VuY2VNcyA9IDI1MDtcblx0XHRpZiAodGhpcy5zZXR0aW5ncy5tYXhGaWxlU2l6ZUtCIDwgNTApIHRoaXMuc2V0dGluZ3MubWF4RmlsZVNpemVLQiA9IDUwO1xuXHRcdHRoaXMuc2V0dGluZ3MuYmF0Y2hDb21taXRNZXNzYWdlID0gdGhpcy5zZXR0aW5ncy5iYXRjaENvbW1pdE1lc3NhZ2UucmVwbGFjZSgvW1xcclxcbl0vZywgJyAnKS5zbGljZSgwLCAxMDApIHx8ICdQdWJsaXNoJztcblx0fVxuXG5cdHByaXZhdGUgdG9CYXNlNjQoc3RyOiBzdHJpbmcpOiBzdHJpbmcgeyByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCAndXRmOCcpLnRvU3RyaW5nKCdiYXNlNjQnKTsgfVxuXG5cdHByaXZhdGUgYXN5bmMgZ2l0aHViUmVxKG1ldGhvZDogJ2dldCd8J3Bvc3QnfCdwYXRjaCd8J2RlbGV0ZSd8J3B1dCcsIHVybDogc3RyaW5nLCBkYXRhPzogYW55KTogUHJvbWlzZTxhbnk+IHtcblx0XHR0cnkgeyBjb25zdCByID0gYXdhaXQgYXhpb3MucmVxdWVzdCh7IG1ldGhvZCwgdXJsLCBkYXRhLCBoZWFkZXJzOiB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLnNldHRpbmdzLmdpdGh1YlRva2VufWAsIEFjY2VwdDogJ2FwcGxpY2F0aW9uL3ZuZC5naXRodWIudjMranNvbicgfSB9KTsgdGhpcy5sb2coJ2dpdGh1Yl9vaycsIHsgbWV0aG9kLCB1cmwsIHN0YXR1czogci5zdGF0dXMgfSk7IHJldHVybiByLmRhdGE7IH1cblx0XHRjYXRjaChlOmFueSl7IGNvbnN0IHM9ZS5yZXNwb25zZT8uc3RhdHVzOyB0aGlzLmxvZygnZ2l0aHViX2VycicseyBtZXRob2QsdXJsLHN0YXR1czpzLCBib2R5OiBlLnJlc3BvbnNlPy5kYXRhIH0sIHM9PT00MDk/J1dBUk4nOidFUlJPUicpOyBpZihzPT09NDA5KSBuZXcgTm90aWNlKCdHaXRIdWIgNDA5IEtvbmZsaWt0Jyk7IGVsc2UgbmV3IE5vdGljZShgR2l0SHViIEZlaGxlciAke3N8fCcnfWApOyByZXR1cm4gbnVsbDsgfVxuXHR9XG5cdHByaXZhdGUgZ2l0aHViR2V0KHVybDpzdHJpbmcpeyByZXR1cm4gdGhpcy5naXRodWJSZXEoJ2dldCcsdXJsKTsgfVxuXHRwcml2YXRlIGdpdGh1YlBvc3QodXJsOnN0cmluZyxkYXRhOmFueSl7IHJldHVybiB0aGlzLmdpdGh1YlJlcSgncG9zdCcsdXJsLGRhdGEpOyB9XG5cdHByaXZhdGUgZ2l0aHViUGF0Y2godXJsOnN0cmluZyxkYXRhOmFueSl7IHJldHVybiB0aGlzLmdpdGh1YlJlcSgncGF0Y2gnLHVybCxkYXRhKTsgfVxuXHRwcml2YXRlIGdpdGh1YkRlbGV0ZSh1cmw6c3RyaW5nLGRhdGE6YW55KXsgcmV0dXJuIHRoaXMuZ2l0aHViUmVxKCdkZWxldGUnLHVybCxkYXRhKTsgfVxuXHRwcml2YXRlIGdpdGh1YlB1dCh1cmw6c3RyaW5nLGRhdGE6YW55KXsgcmV0dXJuIHRoaXMuZ2l0aHViUmVxKCdwdXQnLHVybCxkYXRhKTsgfVxuXG5cdHB1YmxpYyBlbnN1cmVHaXRIdWJDb25maWcoKTogYm9vbGVhbiB7IHJldHVybiAhISh0aGlzLnNldHRpbmdzLnJlcG9VcmkgJiYgdGhpcy5zZXR0aW5ncy5naXRodWJUb2tlbik7IH1cblxuXHRhc3luYyBvbmxvYWQoKSB7XG5cdFx0YXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcblx0XHR0aGlzLmluaXRMb2dnaW5nKCk7XG5cdFx0dGhpcy5yZWdpc3RlclZpZXcoJ2dpdHB1Ymxpc2gtcGVuZGluZy12aWV3JywgbGVhZiA9PiBuZXcgUGVuZGluZ1ZpZXcobGVhZiwgdGhpcykpO1xuXHRcdHRoaXMuYWRkUmliYm9uSWNvbigndXBsb2FkLWNsb3VkJywgJ0dpdCBQdWJsaXNoJywgKCkgPT4gdGhpcy5hY3RpdmF0ZVZpZXcoKSk7XG5cdFx0dGhpcy5jcmVhdGVQdWJsaXNoZWRUb2dnbGUoKTtcblx0XHR0aGlzLmFkZENvbW1hbmRzKCk7XG5cdFx0dGhpcy5yZWdpc3RlckV2ZW50cygpO1xuXHRcdHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgR2l0UHVibGlzaGVyU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXHRcdHRoaXMucmVmcmVzaFB1Ymxpc2hlZFN0YXR1cygpO1xuXHRcdGF3YWl0IHRoaXMuaW5pdGlhbFJlcG9TY2FuKCk7XG5cdH1cblxuXHRvbnVubG9hZCgpIHsgdGhpcy5jbGVhclRpbWVycygpOyB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKCdnaXRwdWJsaXNoLXBlbmRpbmctdmlldycpLmZvckVhY2gobCA9PiBsLmRldGFjaCgpKTsgfVxuXG5cdHByaXZhdGUgYWRkQ29tbWFuZHMoKSB7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHsgaWQ6ICdnaXRwdWItdG9nZ2xlLXB1Ymxpc2hlZCcsIG5hbWU6ICdUb2dnbGUgcHVibGlzaGVkIGZsYWcnLCBjaGVja0NhbGxiYWNrOiBjID0+IHsgY29uc3QgZj10aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpOyBpZighZikgcmV0dXJuIGZhbHNlOyBpZighYykgdGhpcy50b2dnbGVQdWJsaXNoZWQoZik7IHJldHVybiB0cnVlOyB9IH0pO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7IGlkOiAnZ2l0cHViLXB1Ymxpc2gtY3VycmVudCcsIG5hbWU6ICdQdWJsaXNoIGN1cnJlbnQgZmlsZSBub3cnLCBjaGVja0NhbGxiYWNrOiBjID0+IHsgY29uc3QgZj10aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpOyBpZighZikgcmV0dXJuIGZhbHNlOyBpZighYykgdGhpcy5xdWV1ZUZpbGVGb3JQdWJsaXNoKGYpOyByZXR1cm4gdHJ1ZTsgfSB9KTtcblx0XHR0aGlzLmFkZENvbW1hbmQoeyBpZDogJ2dpdHB1Yi1wdWJsaXNoLWFsbCcsIG5hbWU6ICdQdWJsaXNoIGFsbCBwZW5kaW5nIG5vdycsIGNhbGxiYWNrOiBhc3luYyAoKT0+eyBhd2FpdCB0aGlzLnB1Ymxpc2hBbGxQZW5kaW5nKCk7IH0gfSk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHsgaWQ6ICdnaXRwdWItcmVzY2FuJywgbmFtZTogJ1Jlc2NhbiBwdWJsaXNoZWQgZmlsZXMnLCBjYWxsYmFjazogYXN5bmMgKCk9PnsgY29uc3QgcD10aGlzLnBhcnNlUmVwbygpOyBpZighcCl7IG5ldyBOb3RpY2UoJ1JlcG8gdW5nXHUwMEZDbHRpZycpOyByZXR1cm47fSBhd2FpdCB0aGlzLnNjYW5QdWJsaXNoZWRGaWxlcyhwLm93bmVyLHAucmVwbyk7IHRoaXMudXBkYXRlUGVuZGluZ1ZpZXcoKTsgbmV3IE5vdGljZSgnUmVzY2FuIGZlcnRpZycpOyB9IH0pO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7IGlkOiAnZ2l0cHViLXNob3ctaGVscCcsIG5hbWU6ICdTaG93IEdpdCBQdWJsaXNoZXIgSGlsZmUnLCBjYWxsYmFjazogKCk9PiBuZXcgSGVscE1vZGFsKHRoaXMuYXBwKS5vcGVuKCkgfSk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHsgaWQ6ICdnaXRwdWItYWRkLXB1Ymxpc2hlZC1wcm9wZXJ0eScsIG5hbWU6ICdBZGQgcHVibGlzaGVkIHByb3BlcnR5IHRvIGN1cnJlbnQgZmlsZScsIGNoZWNrQ2FsbGJhY2s6IGMgPT4geyBjb25zdCBmPXRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7IGlmKCFmKSByZXR1cm4gZmFsc2U7IGlmKCFjKSB0aGlzLmVuc3VyZVB1Ymxpc2hlZFByb3BlcnR5KGYsZmFsc2UpOyByZXR1cm4gdHJ1ZTsgfSB9KTtcblx0fVxuXG5cdHByaXZhdGUgcmVnaXN0ZXJFdmVudHMoKSB7XG5cdFx0dGhpcy5yZWdpc3RlckV2ZW50KHRoaXMuYXBwLndvcmtzcGFjZS5vbignYWN0aXZlLWxlYWYtY2hhbmdlJywgKCk9PnsgdGhpcy5yZWZyZXNoUHVibGlzaGVkU3RhdHVzKCk7IHRoaXMudXBkYXRlUGVuZGluZ1ZpZXcoKTsgfSkpO1xuXHRcdHRoaXMucmVnaXN0ZXJFdmVudCh0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLm9uKCdjaGFuZ2VkJywgZmlsZT0+eyBjb25zdCBhPXRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7IGlmKGEgJiYgZmlsZS5wYXRoPT09YS5wYXRoKSB0aGlzLnJlZnJlc2hQdWJsaXNoZWRTdGF0dXMoKTsgdGhpcy51cGRhdGVQZW5kaW5nVmlldygpOyB9KSk7XG5cdFx0dGhpcy5yZWdpc3RlckV2ZW50KHRoaXMuYXBwLndvcmtzcGFjZS5vbignZWRpdG9yLWNoYW5nZScsICgpPT57IGNvbnN0IGY9dGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTsgaWYoZikgdGhpcy5oYW5kbGVFZGl0b3JBY3Rpdml0eShmKTsgfSkpO1xuXHRcdHRoaXMucmVnaXN0ZXJFdmVudCh0aGlzLmFwcC52YXVsdC5vbignbW9kaWZ5JywgZmlsZT0+eyBpZighKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkgfHwgZmlsZS5leHRlbnNpb24hPT0nbWQnKSByZXR1cm47IGNvbnN0IGM9dGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7IGlmKGM/LmZyb250bWF0dGVyPy5wdWJsaXNoZWQ9PT10cnVlKXsgdGhpcy5wZW5kaW5nQ2hhbmdlcy5zZXQoZmlsZS5wYXRoLHRydWUpOyB0aGlzLnJlZnJlc2hQdWJsaXNoZWRTdGF0dXMoKTsgdGhpcy51cGRhdGVQZW5kaW5nVmlldygpOyB9IH0pKTtcblx0fVxuXG5cdHByaXZhdGUgYWN0aXZhdGVWaWV3KCkgeyBjb25zdCBsZWF2ZXM9dGhpcy5hcHAud29ya3NwYWNlLmdldExlYXZlc09mVHlwZSgnZ2l0cHVibGlzaC1wZW5kaW5nLXZpZXcnKTsgaWYobGVhdmVzLmxlbmd0aD09PTApeyBjb25zdCBybD10aGlzLmFwcC53b3Jrc3BhY2UuZ2V0UmlnaHRMZWFmKGZhbHNlKTsgaWYocmwpIHJsLnNldFZpZXdTdGF0ZSh7IHR5cGU6J2dpdHB1Ymxpc2gtcGVuZGluZy12aWV3JywgYWN0aXZlOnRydWUgfSk7IH0gZWxzZSB0aGlzLmFwcC53b3Jrc3BhY2UucmV2ZWFsTGVhZihsZWF2ZXNbMF0pOyB9XG5cblx0cHVibGljIGNsZWFyVGltZXJzKCl7IGlmKHRoaXMuaW5hY3Rpdml0eUhhbmRsZSkgY2xlYXJUaW1lb3V0KHRoaXMuaW5hY3Rpdml0eUhhbmRsZSk7IGlmKHRoaXMuc2Vzc2lvbkhhbmRsZSkgY2xlYXJUaW1lb3V0KHRoaXMuc2Vzc2lvbkhhbmRsZSk7IGlmKHRoaXMuZGVib3VuY2VIYW5kbGUpIGNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlSGFuZGxlKTsgdGhpcy5pbmFjdGl2aXR5SGFuZGxlPXRoaXMuc2Vzc2lvbkhhbmRsZT10aGlzLnNlc3Npb25TdGFydD10aGlzLmRlYm91bmNlSGFuZGxlPW51bGw7IH1cblxuXHRwcml2YXRlIGNyZWF0ZVB1Ymxpc2hlZFRvZ2dsZSgpeyB0aGlzLnB1Ymxpc2hlZFN0YXR1c0VsPXRoaXMuYWRkU3RhdHVzQmFySXRlbSgpOyB0aGlzLnB1Ymxpc2hlZFN0YXR1c0VsLmFkZENsYXNzKCdnaXRwdWJsaXNoLXN0YXR1cycpOyB0aGlzLnB1Ymxpc2hlZFN0YXR1c0VsLmNyZWF0ZVNwYW4oeyB0ZXh0OidQdWJsaXNoZWQnIH0pLmFkZENsYXNzKCdnaXRwdWJsaXNoLXN0YXR1cy1sYWJlbCcpOyBjb25zdCB3PXRoaXMucHVibGlzaGVkU3RhdHVzRWwuY3JlYXRlU3Bhbih7IGNsczonZ2l0cHVibGlzaC10b2dnbGUtd3JhcHBlcicgfSk7IGNvbnN0IGlucHV0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7IGlucHV0LnR5cGU9J2NoZWNrYm94JzsgaW5wdXQuY2xhc3NOYW1lPSdnaXRwdWJsaXNoLXRvZ2dsZS1pbnB1dCc7IHcuYXBwZW5kQ2hpbGQoaW5wdXQpOyB0aGlzLnB1Ymxpc2hlZENoZWNrYm94PWlucHV0OyBjb25zdCB0cmFjaz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7IHRyYWNrLmNsYXNzTmFtZT0nZ2l0cHVibGlzaC10b2dnbGUtdHJhY2snOyB0cmFjay50YWJJbmRleD0wOyBjb25zdCBrbm9iPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTsga25vYi5jbGFzc05hbWU9J2dpdHB1Ymxpc2gtdG9nZ2xlLWtub2InOyB0cmFjay5hcHBlbmRDaGlsZChrbm9iKTsgdy5hcHBlbmRDaGlsZCh0cmFjayk7IHRoaXMucHVibGlzaGVkVHJhY2s9dHJhY2s7IGNvbnN0IGFjdD1hc3luYygpPT57IGlmKGlucHV0LmRpc2FibGVkKSByZXR1cm47IGNvbnN0IGY9dGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTsgaWYoIWYpIHJldHVybjsgYXdhaXQgdGhpcy5zZXRQdWJsaXNoZWQoZiwhaW5wdXQuY2hlY2tlZCk7IH07IHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxhY3QpOyB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJyxlPT57IGlmKGUua2V5PT09J0VudGVyJ3x8ZS5rZXk9PT0nICcpeyBlLnByZXZlbnREZWZhdWx0KCk7IGFjdCgpOyB9IH0pOyB9XG5cblx0cHJpdmF0ZSBoYW5kbGVFZGl0b3JBY3Rpdml0eShmaWxlOlRGaWxlKXsgaWYoIXRoaXMuc2V0dGluZ3MuYXV0b1B1Ymxpc2hFbmFibGVkKSByZXR1cm47IHRoaXMubGFzdEFjdGl2aXR5VGltZT1EYXRlLm5vdygpOyBpZighdGhpcy5zZXNzaW9uU3RhcnQpeyB0aGlzLnNlc3Npb25TdGFydD1EYXRlLm5vdygpOyB0aGlzLnJlc2V0U2Vzc2lvblRpbWVyKCk7IH0gdGhpcy5yZXNldEluYWN0aXZpdHlUaW1lcihmaWxlKTsgdGhpcy5yZXNldERlYm91bmNlKCk7IH1cblx0cHJpdmF0ZSByZXNldERlYm91bmNlKCl7IGlmKHRoaXMuZGVib3VuY2VIYW5kbGUpIGNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlSGFuZGxlKTsgdGhpcy5kZWJvdW5jZUhhbmRsZT13aW5kb3cuc2V0VGltZW91dCgoKT0+e30sIHRoaXMuc2V0dGluZ3MuZGVib3VuY2VNcyk7IH1cblx0cHJpdmF0ZSByZXNldEluYWN0aXZpdHlUaW1lcihmaWxlOlRGaWxlKXsgaWYodGhpcy5pbmFjdGl2aXR5SGFuZGxlKSBjbGVhclRpbWVvdXQodGhpcy5pbmFjdGl2aXR5SGFuZGxlKTsgdGhpcy5pbmFjdGl2aXR5SGFuZGxlPXdpbmRvdy5zZXRUaW1lb3V0KGFzeW5jKCk9PnsgYXdhaXQgdGhpcy5wdWJsaXNoRmlsZUlmUGVuZGluZyhmaWxlKTsgdGhpcy5yZWZyZXNoUHVibGlzaGVkU3RhdHVzKCk7IH0sIHRoaXMuc2V0dGluZ3MuaW5hY3Rpdml0eURlbGF5U2VjKjEwMDApOyB9XG5cdHByaXZhdGUgcmVzZXRTZXNzaW9uVGltZXIoKXsgaWYodGhpcy5zZXNzaW9uSGFuZGxlKSBjbGVhclRpbWVvdXQodGhpcy5zZXNzaW9uSGFuZGxlKTsgdGhpcy5zZXNzaW9uSGFuZGxlPXdpbmRvdy5zZXRUaW1lb3V0KGFzeW5jKCk9PnsgYXdhaXQgdGhpcy5wdWJsaXNoQWxsUGVuZGluZygpOyB0aGlzLmNsZWFyVGltZXJzKCk7IHRoaXMucmVmcmVzaFB1Ymxpc2hlZFN0YXR1cygpOyB9LCB0aGlzLnNldHRpbmdzLm1heEludGVydmFsTWluKjYwKjEwMDApOyB9XG5cblx0cHJpdmF0ZSBhc3luYyBwdWJsaXNoRmlsZUlmUGVuZGluZyhmaWxlOlRGaWxlKXsgaWYoIXRoaXMuc2V0dGluZ3MuYXV0b1B1Ymxpc2hFbmFibGVkKSByZXR1cm47IGNvbnN0IGM9dGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7IGlmKGM/LmZyb250bWF0dGVyPy5wdWJsaXNoZWQhPT10cnVlKSByZXR1cm47IGlmKCF0aGlzLnBlbmRpbmdDaGFuZ2VzLmdldChmaWxlLnBhdGgpKSByZXR1cm47IGF3YWl0IHRoaXMucXVldWVGaWxlRm9yUHVibGlzaChmaWxlKTsgfVxuXHRwdWJsaWMgYXN5bmMgcHVibGlzaEFsbFBlbmRpbmcoKXsgaWYoIXRoaXMuc2V0dGluZ3MuYXV0b1B1Ymxpc2hFbmFibGVkKSByZXR1cm47IGZvcihjb25zdCBbcCxwZW5dIG9mIHRoaXMucGVuZGluZ0NoYW5nZXMuZW50cmllcygpKXsgaWYoIXBlbikgY29udGludWU7IGNvbnN0IGY9dGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHApOyBpZihmIGluc3RhbmNlb2YgVEZpbGUpIGF3YWl0IHRoaXMucXVldWVGaWxlRm9yUHVibGlzaChmKTsgfSB9XG5cdHB1YmxpYyBhc3luYyBxdWV1ZUZpbGVGb3JQdWJsaXNoKGZpbGU6VEZpbGUpeyBpZighdGhpcy5pc1NhZmVQYXRoKGZpbGUucGF0aCkpIHJldHVybjsgaWYoYXdhaXQgdGhpcy5pc1Rvb0xhcmdlKGZpbGUpKSB7IHRoaXMubG9nKCdza2lwX2xhcmdlJyx7IHBhdGg6ZmlsZS5wYXRoIH0pOyByZXR1cm47IH0gdGhpcy5wdWJsaXNoUXVldWUuYWRkKGZpbGUucGF0aCk7IGF3YWl0IHRoaXMucHJvY2Vzc1B1Ymxpc2hRdWV1ZSgpOyB9XG5cdHByaXZhdGUgYXN5bmMgaXNUb29MYXJnZShmaWxlOlRGaWxlKXsgY29uc3Qgc3RhdCA9ICh0aGlzLmFwcC52YXVsdC5hZGFwdGVyIGFzIGFueSkuc3RhdD8uKGZpbGUucGF0aCk7IGlmKHN0YXQ/LnNpemUpIHJldHVybiBzdGF0LnNpemUgPiB0aGlzLnNldHRpbmdzLm1heEZpbGVTaXplS0IqMTAyNDsgY29uc3QgY29udGVudD1hd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGZpbGUpOyByZXR1cm4gY29udGVudC5sZW5ndGggPiB0aGlzLnNldHRpbmdzLm1heEZpbGVTaXplS0IqMTAyNDsgfVxuXHRwcml2YXRlIGlzU2FmZVBhdGgocDpzdHJpbmcpeyByZXR1cm4gIXAuc3RhcnRzV2l0aCgnLicpICYmICFwLmluY2x1ZGVzKCcuLicpOyB9XG5cblx0cHJpdmF0ZSBhc3luYyBwcm9jZXNzUHVibGlzaFF1ZXVlKCl7IGlmKHRoaXMucHVibGlzaGluZ0luUHJvZ3Jlc3MpIHJldHVybjsgaWYoIXRoaXMuZW5zdXJlR2l0SHViQ29uZmlnKCkpIHJldHVybjsgdGhpcy5wdWJsaXNoaW5nSW5Qcm9ncmVzcz10cnVlOyB0cnl7IGNvbnN0IHBhdGhzPVsuLi50aGlzLnB1Ymxpc2hRdWV1ZV07IGlmKHBhdGhzLmxlbmd0aD09PTApIHJldHVybjsgYXdhaXQgdGhpcy5wdWJsaXNoQmF0Y2gocGF0aHMpOyBwYXRocy5mb3JFYWNoKHA9PnRoaXMucHVibGlzaFF1ZXVlLmRlbGV0ZShwKSk7IH0gZmluYWxseSB7IHRoaXMucHVibGlzaGluZ0luUHJvZ3Jlc3M9ZmFsc2U7IHRoaXMucmVmcmVzaFB1Ymxpc2hlZFN0YXR1cygpOyB0aGlzLnVwZGF0ZVBlbmRpbmdWaWV3KCk7IH0gfVxuXG5cdHByaXZhdGUgcGFyc2VSZXBvKCk6IHsgb3duZXI6c3RyaW5nOyByZXBvOnN0cmluZyB9IHwgbnVsbCB7IGNvbnN0IHU9dGhpcy5zZXR0aW5ncy5yZXBvVXJpOyBpZighdSkgcmV0dXJuIG51bGw7IGNvbnN0IG09dS5tYXRjaCgvXmh0dHBzOlxcL1xcL2dpdGh1YlxcLmNvbVxcLyhbXFx3Li1dKylcXC8oW1xcdy4tXSspKD86XFwuZ2l0KT8kLyk7IHJldHVybiBtP3sgb3duZXI6bVsxXSwgcmVwbzptWzJdIH06bnVsbDsgfVxuXHRwcml2YXRlIGFzeW5jIGZldGNoQ29udGVudHNTaGEob3duZXI6c3RyaW5nLCByZXBvOnN0cmluZywgcDpzdHJpbmcpeyBjb25zdCByPWF3YWl0IHRoaXMuZ2l0aHViR2V0KGBodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zLyR7b3duZXJ9LyR7cmVwb30vY29udGVudHMvJHtlbmNvZGVVUklDb21wb25lbnQocCl9P3JlZj0ke3RoaXMuc2V0dGluZ3MuZGVmYXVsdEJyYW5jaH1gKTsgcmV0dXJuIHI/LnNoYXx8bnVsbDsgfVxuXHRwcml2YXRlIGFzeW5jIGVuc3VyZUJyYW5jaEV4aXN0cyhvd25lcjpzdHJpbmcsIHJlcG86c3RyaW5nKXsgY29uc3QgcmVmVXJsPWBodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zLyR7b3duZXJ9LyR7cmVwb30vZ2l0L3JlZi9oZWFkcy8ke3RoaXMuc2V0dGluZ3MuZGVmYXVsdEJyYW5jaH1gOyBjb25zdCByZWY9YXdhaXQgdGhpcy5naXRodWJHZXQocmVmVXJsKTsgaWYocmVmPy5vYmplY3Q/LnNoYSkgcmV0dXJuIHJlZi5vYmplY3Quc2hhOyBjb25zdCBvaz1hd2FpdCB0aGlzLmluaXRpYWxpemVCcmFuY2gob3duZXIscmVwbyk7IGlmKCFvaykgcmV0dXJuIG51bGw7IGNvbnN0IHJlZjI9YXdhaXQgdGhpcy5naXRodWJHZXQocmVmVXJsKTsgcmV0dXJuIHJlZjI/Lm9iamVjdD8uc2hhfHxudWxsOyB9XG5cdHByaXZhdGUgYXN5bmMgaW5pdGlhbGl6ZUJyYW5jaChvd25lcjpzdHJpbmcsIHJlcG86c3RyaW5nKXsgdHJ5eyBjb25zdCBwYXRoTmFtZT0nLmdpdGtlZXAnOyBjb25zdCByZXM9YXdhaXQgdGhpcy5naXRodWJQdXQoYGh0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmVwb3MvJHtvd25lcn0vJHtyZXBvfS9jb250ZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXRoTmFtZSl9YCwgeyBtZXNzYWdlOidJbml0aWFsaXplIGJyYW5jaCcsIGNvbnRlbnQ6dGhpcy50b0Jhc2U2NCgnaW5pdCcpLCBicmFuY2g6dGhpcy5zZXR0aW5ncy5kZWZhdWx0QnJhbmNoIH0pOyByZXR1cm4gISFyZXM/LmNvbnRlbnQ/LnNoYTsgfSBjYXRjaHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuXHRwcml2YXRlIGFzeW5jIHB1Ymxpc2hCYXRjaChwYXRoczpzdHJpbmdbXSl7IHRoaXMubG9nKCdiYXRjaF9zdGFydCcseyBjb3VudDpwYXRocy5sZW5ndGggfSk7IGNvbnN0IHByPXRoaXMucGFyc2VSZXBvKCk7IGlmKCFwcil7IHRoaXMubG9nKCdiYXRjaF9hYm9ydF9wYXJzZScpOyByZXR1cm47IH0gY29uc3QgeyBvd25lciwgcmVwbyB9PXByOyBjb25zdCBiYXNlU2hhPWF3YWl0IHRoaXMuZW5zdXJlQnJhbmNoRXhpc3RzKG93bmVyLHJlcG8pOyBpZighYmFzZVNoYSl7IHRoaXMubG9nKCdiYXRjaF9hYm9ydF9icmFuY2gnKTsgcmV0dXJuOyB9IGNvbnN0IGJsb2JzOnsgcGF0aDpzdHJpbmc7IG1vZGU6c3RyaW5nOyB0eXBlOnN0cmluZzsgc2hhOnN0cmluZyB9W109W107IGZvcihjb25zdCBwIG9mIHBhdGhzKXsgY29uc3QgZj10aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocCk7IGlmKCEoZiBpbnN0YW5jZW9mIFRGaWxlKSl7IHRoaXMubG9nKCdza2lwX25vdF9maWxlJyx7IHBhdGg6cCB9KTsgY29udGludWU7IH0gY29uc3QgY29udGVudD1hd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGYpOyBjb25zdCBibG9iPWF3YWl0IHRoaXMuZ2l0aHViUG9zdChgaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9yZXBvcy8ke293bmVyfS8ke3JlcG99L2dpdC9ibG9ic2AsIHsgY29udGVudCwgZW5jb2Rpbmc6J3V0Zi04JyB9KTsgaWYoYmxvYj8uc2hhKSBibG9icy5wdXNoKHsgcGF0aDpwLCBtb2RlOicxMDA2NDQnLCB0eXBlOidibG9iJywgc2hhOmJsb2Iuc2hhIH0pOyBlbHNlIHRoaXMubG9nKCdibG9iX2ZhaWwnLHsgcGF0aDpwIH0pOyB9IGlmKCFibG9icy5sZW5ndGgpeyB0aGlzLmxvZygnYmF0Y2hfbm9fYmxvYnMnKTsgcmV0dXJuOyB9IGNvbnN0IHRyZWU9YXdhaXQgdGhpcy5naXRodWJQb3N0KGBodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zLyR7b3duZXJ9LyR7cmVwb30vZ2l0L3RyZWVzYCwgeyBiYXNlX3RyZWU6YmFzZVNoYSwgdHJlZTpibG9icyB9KTsgaWYoIXRyZWU/LnNoYSl7IHRoaXMubG9nKCd0cmVlX2ZhaWwnKTsgcmV0dXJuOyB9IGNvbnN0IG1zZz1gJHt0aGlzLnNldHRpbmdzLmJhdGNoQ29tbWl0TWVzc2FnZX0gKCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfSlgOyBjb25zdCBjb21taXQ9YXdhaXQgdGhpcy5naXRodWJQb3N0KGBodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zLyR7b3duZXJ9LyR7cmVwb30vZ2l0L2NvbW1pdHNgLCB7IG1lc3NhZ2U6bXNnLCB0cmVlOnRyZWUuc2hhLCBwYXJlbnRzOltiYXNlU2hhXSB9KTsgaWYoIWNvbW1pdD8uc2hhKXsgdGhpcy5sb2coJ2NvbW1pdF9mYWlsJyk7IHJldHVybjsgfSBjb25zdCB1cGRhdGVkPWF3YWl0IHRoaXMuZ2l0aHViUGF0Y2goYGh0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmVwb3MvJHtvd25lcn0vJHtyZXBvfS9naXQvcmVmcy9oZWFkcy8ke3RoaXMuc2V0dGluZ3MuZGVmYXVsdEJyYW5jaH1gLCB7IHNoYTpjb21taXQuc2hhLCBmb3JjZTpmYWxzZSB9KTsgaWYodXBkYXRlZCl7IGZvcihjb25zdCBwIG9mIHBhdGhzKSB0aGlzLnBlbmRpbmdDaGFuZ2VzLnNldChwLGZhbHNlKTsgYXdhaXQgdGhpcy5zYXZlU2V0dGluZ3MoKTsgdGhpcy5sb2coJ2JhdGNoX29rJyx7IGNvbW1pdDpjb21taXQuc2hhLCBmaWxlczpwYXRocy5sZW5ndGggfSk7IG5ldyBOb3RpY2UoYFB1Ymxpc2hlZCAke3BhdGhzLmxlbmd0aH0gRGF0ZWllbmApOyB9IGVsc2UgdGhpcy5sb2coJ3JlZl9mYWlsJyk7IH1cblxuXHRwcml2YXRlIGFzeW5jIGRlbGV0ZUZpbGVGcm9tUmVwbyhmaWxlOlRGaWxlKXsgY29uc3QgcHI9dGhpcy5wYXJzZVJlcG8oKTsgaWYoIXByKSByZXR1cm47IGNvbnN0IHsgb3duZXIsIHJlcG8gfT1wcjsgY29uc3Qgc2hhPWF3YWl0IHRoaXMuZmV0Y2hDb250ZW50c1NoYShvd25lcixyZXBvLGZpbGUucGF0aCk7IGlmKCFzaGEpeyB0aGlzLmxvZygnZGVsZXRlX21pc3NpbmdfcmVtb3RlJyx7IHBhdGg6ZmlsZS5wYXRoIH0pOyByZXR1cm47IH0gY29uc3QgcmVzPWF3YWl0IHRoaXMuZ2l0aHViRGVsZXRlKGBodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zLyR7b3duZXJ9LyR7cmVwb30vY29udGVudHMvJHtlbmNvZGVVUklDb21wb25lbnQoZmlsZS5wYXRoKX1gLCB7IG1lc3NhZ2U6YFVucHVibGlzaCAke2ZpbGUucGF0aH1gLCBicmFuY2g6dGhpcy5zZXR0aW5ncy5kZWZhdWx0QnJhbmNoLCBzaGEgfSk7IGlmKHJlcyl7IHRoaXMucGVuZGluZ0NoYW5nZXMuZGVsZXRlKGZpbGUucGF0aCk7IHRoaXMubG9nKCdkZWxldGVkJyx7IHBhdGg6ZmlsZS5wYXRoIH0pOyB9IH1cblxuXHRwcml2YXRlIGFzeW5jIHRvZ2dsZVB1Ymxpc2hlZChmaWxlOlRGaWxlKXsgY29uc3QgY3VyPWF3YWl0IHRoaXMuZ2V0UHVibGlzaGVkKGZpbGUpOyBhd2FpdCB0aGlzLnNldFB1Ymxpc2hlZChmaWxlLCFjdXIpOyB9XG5cdHByaXZhdGUgYXN5bmMgc2V0UHVibGlzaGVkKGZpbGU6VEZpbGUsIHZhbHVlOmJvb2xlYW4peyBhd2FpdCB0aGlzLmFwcC5maWxlTWFuYWdlci5wcm9jZXNzRnJvbnRNYXR0ZXIoZmlsZSxmbT0+eyBmbS5wdWJsaXNoZWQ9dmFsdWU7IH0pOyBpZih2YWx1ZSl7IG5ldyBOb3RpY2UoYCR7ZmlsZS5iYXNlbmFtZX0gcHVibGlzaGVkYCk7IHRoaXMucGVuZGluZ0NoYW5nZXMuc2V0KGZpbGUucGF0aCx0cnVlKTsgdGhpcy5sb2coJ2ZsYWdfb24nLHsgcGF0aDpmaWxlLnBhdGggfSk7IH0gZWxzZSB7IG5ldyBOb3RpY2UoYCR7ZmlsZS5iYXNlbmFtZX0gdW5wdWJsaXNoZWRgKTsgYXdhaXQgdGhpcy5kZWxldGVGaWxlRnJvbVJlcG8oZmlsZSk7IHRoaXMubG9nKCdmbGFnX29mZicseyBwYXRoOmZpbGUucGF0aCB9KTsgfSBzZXRUaW1lb3V0KCgpPT57IHRoaXMucmVmcmVzaFB1Ymxpc2hlZFN0YXR1cygpOyB0aGlzLnVwZGF0ZVBlbmRpbmdWaWV3KCk7IH0sMTUwKTsgfVxuXHRwcml2YXRlIGFzeW5jIGVuc3VyZVB1Ymxpc2hlZFByb3BlcnR5KGZpbGU6VEZpbGUsc2lsZW50OmJvb2xlYW49ZmFsc2UpeyBjb25zdCBjPXRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpOyBjb25zdCBoYXM9Yz8uZnJvbnRtYXR0ZXIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGMuZnJvbnRtYXR0ZXIsJ3B1Ymxpc2hlZCcpOyBpZihoYXMpeyBpZighc2lsZW50KSBuZXcgTm90aWNlKCdwdWJsaXNoZWQgZXhpc3RpZXJ0Jyk7IHJldHVybiBmYWxzZTsgfSBhd2FpdCB0aGlzLmFwcC5maWxlTWFuYWdlci5wcm9jZXNzRnJvbnRNYXR0ZXIoZmlsZSxmbT0+eyBmbS5wdWJsaXNoZWQ9ZmFsc2U7IH0pOyBpZighc2lsZW50KSBuZXcgTm90aWNlKCdwdWJsaXNoZWQgaGluenVnZWZcdTAwRkNndCcpOyBzZXRUaW1lb3V0KCgpPT57IHRoaXMucmVmcmVzaFB1Ymxpc2hlZFN0YXR1cygpOyB0aGlzLnVwZGF0ZVBlbmRpbmdWaWV3KCk7IH0sMTIwKTsgcmV0dXJuIHRydWU7IH1cblx0cHJpdmF0ZSBhc3luYyBnZXRQdWJsaXNoZWQoZmlsZTpURmlsZSl7IGNvbnN0IGM9dGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7IHJldHVybiBjPy5mcm9udG1hdHRlcj8ucHVibGlzaGVkPT09dHJ1ZTsgfVxuXG5cdHByaXZhdGUgcmVmcmVzaFB1Ymxpc2hlZFN0YXR1cygpeyBpZighdGhpcy5wdWJsaXNoZWRDaGVja2JveHx8IXRoaXMucHVibGlzaGVkVHJhY2spIHJldHVybjsgY29uc3QgZj10aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpOyBpZighZil7IHRoaXMucHVibGlzaGVkQ2hlY2tib3guY2hlY2tlZD1mYWxzZTsgdGhpcy5wdWJsaXNoZWRDaGVja2JveC5kaXNhYmxlZD10cnVlOyB0aGlzLnB1Ymxpc2hlZFRyYWNrLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLW9uJyk7IHRoaXMucHVibGlzaGVkVHJhY2suY2xhc3NMaXN0LmFkZCgnaXMtZGlzYWJsZWQnKTsgdGhpcy5wdWJsaXNoZWRUcmFjay5jbGFzc0xpc3QucmVtb3ZlKCdoYXMtcGVuZGluZycpOyByZXR1cm47IH0gdGhpcy5wdWJsaXNoZWRDaGVja2JveC5kaXNhYmxlZD1mYWxzZTsgY29uc3QgYz10aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmKTsgY29uc3QgdmFsPWM/LmZyb250bWF0dGVyPy5wdWJsaXNoZWQ9PT10cnVlOyB0aGlzLnB1Ymxpc2hlZENoZWNrYm94LmNoZWNrZWQ9dmFsOyB0aGlzLnB1Ymxpc2hlZFRyYWNrLmNsYXNzTGlzdC50b2dnbGUoJ2lzLW9uJyx2YWwpOyB0aGlzLnB1Ymxpc2hlZFRyYWNrLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWRpc2FibGVkJyk7IGNvbnN0IHBlbj10aGlzLnBlbmRpbmdDaGFuZ2VzLmdldChmLnBhdGgpOyB0aGlzLnB1Ymxpc2hlZFRyYWNrLmNsYXNzTGlzdC50b2dnbGUoJ2hhcy1wZW5kaW5nJywgISFwZW4gJiYgdmFsKTsgfVxuXHRwcml2YXRlIHVwZGF0ZVBlbmRpbmdWaWV3KCl7IGZvcihjb25zdCBsZWFmIG9mIHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWF2ZXNPZlR5cGUoJ2dpdHB1Ymxpc2gtcGVuZGluZy12aWV3JykpeyBjb25zdCB2PWxlYWYudmlldzsgaWYodiBpbnN0YW5jZW9mIFBlbmRpbmdWaWV3KSB2LnJlbmRlcigpOyB9IH1cblxuXHRwcml2YXRlIGluaXRMb2dnaW5nKCl7IHRyeXsgY29uc3QgYmFzZT0odGhpcy5hcHAudmF1bHQgYXMgYW55KS5hZGFwdGVyPy5nZXRCYXNlUGF0aD8uKCl8fCcnOyBpZihiYXNlKXsgdGhpcy5sb2dQYXRoPXBhdGguam9pbihiYXNlLCcub2JzaWRpYW4nLCdwbHVnaW5zJywnb2JzaWRpYW4tZ2l0cHVibGlzaCcsJ2dpdHB1Ymxpc2gtbG9nLm5kanNvbicpOyB0aGlzLmVuc3VyZUxvZ0ZpbGUoKTsgdGhpcy5sb2coJ2xvZ2dlcl9pbml0JywgeyBwYXRoOnRoaXMubG9nUGF0aCB9KTsgfSB9IGNhdGNoIHsgdGhpcy5sb2dQYXRoPW51bGw7IH0gfVxuXHRwcml2YXRlIGVuc3VyZUxvZ0ZpbGUoKXsgaWYoIXRoaXMubG9nUGF0aCkgcmV0dXJuOyB0cnl7IGlmKCFmcy5leGlzdHNTeW5jKHRoaXMubG9nUGF0aCkpIGZzLndyaXRlRmlsZVN5bmModGhpcy5sb2dQYXRoLCcnKTsgY29uc3Qgcz1mcy5zdGF0U3luYyh0aGlzLmxvZ1BhdGgpOyBpZihzLnNpemU+MV8wMDBfMDAwKXsgY29uc3Qgcm90PXRoaXMubG9nUGF0aCsnLjEnOyB0cnl7IGZzLnJlbmFtZVN5bmModGhpcy5sb2dQYXRoLHJvdCk7IH1jYXRjaHt9IGZzLndyaXRlRmlsZVN5bmModGhpcy5sb2dQYXRoLCcnKTsgdGhpcy5sb2coJ2xvZ19yb3RhdGUnLHsgb2xkOnJvdCB9KTsgfSB9IGNhdGNoe30gfVxuXHRwcml2YXRlIGxvZyhtc2c6c3RyaW5nLCBtZXRhOmFueT17fSwgbGV2ZWw6J0lORk8nfCdXQVJOJ3wnRVJST1InPSdJTkZPJyl7IGlmKCF0aGlzLmxvZ1BhdGgpIHJldHVybjsgY29uc3QgZW50cnk9eyB0czpuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksIGxldmVsLCBtc2csIC4uLm1ldGEgfTsgdHJ5eyBmcy5hcHBlbmRGaWxlU3luYyh0aGlzLmxvZ1BhdGgsIEpTT04uc3RyaW5naWZ5KGVudHJ5KSsnXFxuJyk7IH0gY2F0Y2h7fSB9XG5cblx0cHJpdmF0ZSBhc3luYyBpbml0aWFsUmVwb1NjYW4oKXsgaWYoIXRoaXMuZW5zdXJlR2l0SHViQ29uZmlnKCkpIHJldHVybjsgY29uc3QgcHI9dGhpcy5wYXJzZVJlcG8oKTsgaWYoIXByKSByZXR1cm47IGNvbnN0IHJlcG9JbmZvPWF3YWl0IHRoaXMuZ2l0aHViR2V0KGBodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zLyR7cHIub3duZXJ9LyR7cHIucmVwb31gKTsgaWYoIXJlcG9JbmZvKSByZXR1cm47IGNvbnN0IGJhc2VTaGE9YXdhaXQgdGhpcy5lbnN1cmVCcmFuY2hFeGlzdHMocHIub3duZXIscHIucmVwbyk7IGlmKCFiYXNlU2hhKSByZXR1cm47IGF3YWl0IHRoaXMuc2NhblB1Ymxpc2hlZEZpbGVzKHByLm93bmVyLHByLnJlcG8pOyB0aGlzLnVwZGF0ZVBlbmRpbmdWaWV3KCk7IH1cblx0cHJpdmF0ZSBhc3luYyBzY2FuUHVibGlzaGVkRmlsZXMob3duZXI6c3RyaW5nLCByZXBvOnN0cmluZyl7IGNvbnN0IGZpbGVzPXRoaXMuYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTsgbGV0IHRvdGFsPTAsb3V0T2ZTeW5jPTAsbWlzc2luZz0wOyBmb3IoY29uc3QgZiBvZiBmaWxlcyl7IGNvbnN0IGM9dGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZik7IGlmKGM/LmZyb250bWF0dGVyPy5wdWJsaXNoZWQhPT10cnVlKSBjb250aW51ZTsgdG90YWwrKzsgY29uc3QgcmVtb3RlPWF3YWl0IHRoaXMuZ2l0aHViR2V0KGBodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zLyR7b3duZXJ9LyR7cmVwb30vY29udGVudHMvJHtlbmNvZGVVUklDb21wb25lbnQoZi5wYXRoKX0/cmVmPSR7dGhpcy5zZXR0aW5ncy5kZWZhdWx0QnJhbmNofWApOyBpZighcmVtb3RlfHwhcmVtb3RlLmNvbnRlbnQpeyB0aGlzLnBlbmRpbmdDaGFuZ2VzLnNldChmLnBhdGgsdHJ1ZSk7IG1pc3NpbmcrKzsgY29udGludWU7IH0gY29uc3QgbG9jYWw9YXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChmKTsgY29uc3QgbG9jYWxCNjQ9dGhpcy50b0Jhc2U2NChsb2NhbCk7IGNvbnN0IHJlbW90ZUI2ND0ocmVtb3RlLmNvbnRlbnQgYXMgc3RyaW5nKS5yZXBsYWNlKC9cXG4vZywnJyk7IGlmKGxvY2FsQjY0IT09cmVtb3RlQjY0KXsgdGhpcy5wZW5kaW5nQ2hhbmdlcy5zZXQoZi5wYXRoLHRydWUpOyBvdXRPZlN5bmMrKzsgfSBlbHNlIHsgdGhpcy5wZW5kaW5nQ2hhbmdlcy5zZXQoZi5wYXRoLGZhbHNlKTsgdGhpcy5zaGFNYXBbZi5wYXRoXT1yZW1vdGUuc2hhOyB9IH0gdGhpcy5sYXN0U2NhblN1bW1hcnk9eyB0b3RhbCxvdXRPZlN5bmMsbWlzc2luZywgdHM6RGF0ZS5ub3coKSB9OyB0aGlzLmxvZygnc2Nhbl9kb25lJywgdGhpcy5sYXN0U2NhblN1bW1hcnkpOyB9XG59XG5cbmNsYXNzIEdpdFB1Ymxpc2hlclNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcblx0Y29uc3RydWN0b3IoYXBwOkFwcCwgcHJpdmF0ZSBwbHVnaW46R2l0UHVibGlzaGVyUGx1Z2luKXsgc3VwZXIoYXBwLCBwbHVnaW4pOyB9XG5cdGRpc3BsYXkoKXsgY29uc3QgeyBjb250YWluZXJFbCB9PXRoaXM7IGNvbnRhaW5lckVsLmVtcHR5KCk7IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicseyB0ZXh0OidHaXQgUHVibGlzaGVyIEVpbnN0ZWxsdW5nZW4nIH0pOyBjb250YWluZXJFbC5jcmVhdGVFbCgncCcseyB0ZXh0OidEaWVzZXMgUGx1Z2luIHZlclx1MDBGNmZmZW50bGljaHQgTWFya2Rvd24tRGF0ZWllbiBtaXQgRnJvbnRtYXR0ZXIgcHVibGlzaGVkOnRydWUgYXV0b21hdGlzaWVydCBhdWYgZWluIEdpdEh1YiBSZXBvc2l0b3J5LicgfSk7IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJyx7IHRleHQ6J0FibGF1ZjogV2VubiBkdSB0aXBwc3Qgc3RhcnRlbiBUaW1lci4gSW5ha3Rpdml0XHUwMEU0dCBsXHUwMEY2c3QgRWluemVsLVB1Ymxpc2ggYXVzLCBzcFx1MDBFNHRlc3RlbnMgbmFjaCBTZXNzaW9uLUludGVydmFsbCB3ZXJkZW4gYWxsZSBwZW5kaW5nIERhdGVpZW4gaW0gQmF0Y2ggXHUwMEZDYmVydHJhZ2VuLicgfSk7IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJyx7IHRleHQ6J1RvZ2dsZSB1bnRlbiByZWNodHMgemVpZ3QgU3RhdHVzIChnclx1MDBGQ249cHVibGlzaGVkLCBibGF1PXBlbmRpbmcgXHUwMEM0bmRlcnVuZ2VuKS4gVW5wdWJsaXNoZWQgZW50ZmVybnQgRGF0ZWkgYXVzIFJlcG8uJyB9KTtcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0TmFtZSgnR2l0SHViIFJlcG8gVVJMJykuc2V0RGVzYygnRm9ybWF0OiBodHRwczovL2dpdGh1Yi5jb20vT1dORVIvUkVQTyBvZGVyIG1pdCAuZ2l0JykuYWRkVGV4dCh0PT50LnNldFBsYWNlaG9sZGVyKCdodHRwczovL2dpdGh1Yi5jb20vdXNlci9yZXBvJykuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucmVwb1VyaSkub25DaGFuZ2UoYXN5bmMgdj0+eyB0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXBvVXJpPXYudHJpbSgpOyB0aGlzLnBsdWdpbi5zYW5pdGl6ZVNldHRpbmdzKCk7IGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpOyB9KSk7XG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldE5hbWUoJ0dpdEh1YiBUb2tlbicpLnNldERlc2MoJ0ZpbmUtZ3JhaW5lZCBUb2tlbjogQ29udGVudHMgUmVhZC9Xcml0ZScpLmFkZFRleHQodD0+eyB0LmlucHV0RWwudHlwZT0ncGFzc3dvcmQnOyB0LnNldFBsYWNlaG9sZGVyKCdnaHBfLi4uJykuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZ2l0aHViVG9rZW4pLm9uQ2hhbmdlKGFzeW5jIHY9PnsgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZ2l0aHViVG9rZW49di50cmltKCk7IGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpOyB9KTsgfSk7XG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldE5hbWUoJ0F1dG8gUHVibGlzaCcpLnNldERlc2MoJ1NjaGFsdGV0IGRlbiBhdXRvbWF0aXNjaGVuIE1lY2hhbmlzbXVzIGFuL2F1cycpLmFkZFRvZ2dsZSh0PT50LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmF1dG9QdWJsaXNoRW5hYmxlZCkub25DaGFuZ2UoYXN5bmMgdj0+eyB0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdXRvUHVibGlzaEVuYWJsZWQ9djsgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7IH0pKTtcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0TmFtZSgnSW5ha3Rpdml0XHUwMEU0dHMtU2VrdW5kZW4nKS5zZXREZXNjKCdaZWl0IG9obmUgVGlwcCBiaXMgRWluemVsLVB1Ymxpc2gnKS5hZGRUZXh0KHQ9PnQuc2V0VmFsdWUoU3RyaW5nKHRoaXMucGx1Z2luLnNldHRpbmdzLmluYWN0aXZpdHlEZWxheVNlYykpLm9uQ2hhbmdlKGFzeW5jIHY9PnsgY29uc3Qgbj1wYXJzZUludCh2LDEwKTsgaWYoIWlzTmFOKG4pJiZuPj01KSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmFjdGl2aXR5RGVsYXlTZWM9bjsgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7IH0pKTtcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0TmFtZSgnU2Vzc2lvbi1NaW51dGVuJykuc2V0RGVzYygnTWF4IFplaXQgYmlzIEJhdGNoLVB1Ymxpc2gnKS5hZGRUZXh0KHQ9PnQuc2V0VmFsdWUoU3RyaW5nKHRoaXMucGx1Z2luLnNldHRpbmdzLm1heEludGVydmFsTWluKSkub25DaGFuZ2UoYXN5bmMgdj0+eyBjb25zdCBuPXBhcnNlSW50KHYsMTApOyBpZighaXNOYU4obikmJm4+PTEpIHRoaXMucGx1Z2luLnNldHRpbmdzLm1heEludGVydmFsTWluPW47IGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpOyB9KSk7XG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldE5hbWUoJ0RlYm91bmNlIChtcyknKS5zZXREZXNjKCdFaW5nYWJlLUVudHByZWxsdW5nJykuYWRkVGV4dCh0PT50LnNldFZhbHVlKFN0cmluZyh0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWJvdW5jZU1zKSkub25DaGFuZ2UoYXN5bmMgdj0+eyBjb25zdCBuPXBhcnNlSW50KHYsMTApOyBpZighaXNOYU4obikmJm4+PTI1MCkgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVib3VuY2VNcz1uOyBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTsgfSkpO1xuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXROYW1lKCdCYXRjaCBDb21taXQgTWVzc2FnZScpLnNldERlc2MoJ1ByZWZpeCBmXHUwMEZDciBDb21taXRzJykuYWRkVGV4dCh0PT50LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmJhdGNoQ29tbWl0TWVzc2FnZSkub25DaGFuZ2UoYXN5bmMgdj0+eyB0aGlzLnBsdWdpbi5zZXR0aW5ncy5iYXRjaENvbW1pdE1lc3NhZ2U9di50cmltKCk7IHRoaXMucGx1Z2luLnNhbml0aXplU2V0dGluZ3MoKTsgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7IH0pKTtcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0TmFtZSgnQnJhbmNoJykuc2V0RGVzYygnWmllbGJyYW5jaCcpLmFkZFRleHQodD0+dC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWZhdWx0QnJhbmNoKS5vbkNoYW5nZShhc3luYyB2PT57IGlmKHYudHJpbSgpKSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWZhdWx0QnJhbmNoPXYudHJpbSgpOyB0aGlzLnBsdWdpbi5zYW5pdGl6ZVNldHRpbmdzKCk7IGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpOyB9KSk7XG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldE5hbWUoJ01heCBEYXRlaWdyXHUwMEY2XHUwMERGZSAoS0IpJykuc2V0RGVzYygnXHUwMERDYmVyc2NocmVpdGV0IGVpbmUgRGF0ZWkgZGllc2VuIFdlcnQgd2lyZCBzaWUgbmljaHQgdmVyXHUwMEY2ZmZlbnRsaWNodCcpLmFkZFRleHQodD0+dC5zZXRWYWx1ZShTdHJpbmcodGhpcy5wbHVnaW4uc2V0dGluZ3MubWF4RmlsZVNpemVLQikpLm9uQ2hhbmdlKGFzeW5jIHY9PnsgY29uc3Qgbj1wYXJzZUludCh2LDEwKTsgaWYoIWlzTmFOKG4pJiZuPj01MCkgdGhpcy5wbHVnaW4uc2V0dGluZ3MubWF4RmlsZVNpemVLQj1uOyBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTsgfSkpO1xuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMycseyB0ZXh0OidTaWNoZXJoZWl0JyB9KTtcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgndWwnLHsgdGV4dDonJyB9KS5hcHBlbmRDaGlsZCh0aGlzLmJ1aWxkQnVsbGV0KCdUb2tlbiB3aXJkIG5pZSBnZWxvZ2d0LicpKTsgY29udGFpbmVyRWwuY3JlYXRlRWwoJ3VsJyx7IHRleHQ6JycgfSkuYXBwZW5kQ2hpbGQodGhpcy5idWlsZEJ1bGxldCgnUGZhZHZhbGlkaWVydW5nIHZlcmhpbmRlcnQgLi4vIFRyYXZlcnNhbC4nKSk7IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCd1bCcseyB0ZXh0OicnIH0pLmFwcGVuZENoaWxkKHRoaXMuYnVpbGRCdWxsZXQoJ0dyXHUwMEY2XHUwMERGZW5saW1pdCBzY2hcdTAwRkN0enQgdm9yIGdyb1x1MDBERmVuIENvbW1pdHMuJykpO1xuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMycseyB0ZXh0OidOdXR6dW5nc3NjaHJpdHRlJyB9KTtcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnb2wnLHsgdGV4dDonJyB9KS5hcHBlbmRDaGlsZCh0aGlzLmJ1aWxkQnVsbGV0KCdSZXBvIFVSTCAmIFRva2VuIHNldHplbi4nKSk7IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdvbCcseyB0ZXh0OicnIH0pLmFwcGVuZENoaWxkKHRoaXMuYnVpbGRCdWxsZXQoJ0luIEZyb250bWF0dGVyIHB1Ymxpc2hlZDp0cnVlIGhpbnp1Zlx1MDBGQ2dlbi4nKSk7IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdvbCcseyB0ZXh0OicnIH0pLmFwcGVuZENoaWxkKHRoaXMuYnVpbGRCdWxsZXQoJ1NjaHJlaWJlbiBcdTIwMTMgVGltZXIgdmVyXHUwMEY2ZmZlbnRsaWNoZW4gYXV0b21hdGlzY2guJykpOyBjb250YWluZXJFbC5jcmVhdGVFbCgnb2wnLHsgdGV4dDonJyB9KS5hcHBlbmRDaGlsZCh0aGlzLmJ1aWxkQnVsbGV0KCdWaWV3IG51dHplbiBmXHUwMEZDciBcdTAwRENiZXJibGljayAmIG1hbnVlbGxlbiBQdWJsaXNoLicpKTtcblx0fVxuXHRwcml2YXRlIGJ1aWxkQnVsbGV0KHRleHQ6c3RyaW5nKXsgY29uc3QgbGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTsgbGkudGV4dENvbnRlbnQ9dGV4dDsgcmV0dXJuIGxpOyB9XG59XG5cbmNsYXNzIFBlbmRpbmdWaWV3IGV4dGVuZHMgSXRlbVZpZXcge1xuXHRjb25zdHJ1Y3RvcihsZWFmOldvcmtzcGFjZUxlYWYsIHByaXZhdGUgcGx1Z2luOkdpdFB1Ymxpc2hlclBsdWdpbil7IHN1cGVyKGxlYWYpOyB9XG5cdGdldFZpZXdUeXBlKCl7IHJldHVybiAnZ2l0cHVibGlzaC1wZW5kaW5nLXZpZXcnOyB9XG5cdGdldERpc3BsYXlUZXh0KCl7IHJldHVybiAnR2l0IFB1Ymxpc2gnOyB9XG5cdGdldEljb24oKXsgcmV0dXJuICd1cGxvYWQtY2xvdWQnOyB9XG5cdGFzeW5jIG9uT3BlbigpeyB0aGlzLnJlbmRlcigpOyB9XG5cdGFzeW5jIG9uQ2xvc2UoKXt9XG5cdHJlbmRlcigpeyBjb25zdCBlbD10aGlzLmNvbnRhaW5lckVsOyBlbC5lbXB0eSgpOyBlbC5hZGRDbGFzcygnZ2l0cHVibGlzaC12aWV3Jyk7IGVsLmNyZWF0ZUVsKCdoMycseyB0ZXh0OidQZW5kaW5nIENoYW5nZXMnIH0pOyBpZighdGhpcy5wbHVnaW4uZW5zdXJlR2l0SHViQ29uZmlnKCkpeyBlbC5jcmVhdGVFbCgnZGl2Jyx7IHRleHQ6J0tvbmZpZ3VyYXRpb24gZmVobHQgKFJlcG8gLyBUb2tlbikuJyB9KTsgcmV0dXJuOyB9IGNvbnN0IGxpc3Q9ZWwuY3JlYXRlRGl2KHsgY2xzOidnaXRwdWJsaXNoLXBlbmRpbmctbGlzdCcgfSk7IGxldCBjb3VudD0wOyBmb3IoY29uc3QgW3AscGVuXSBvZiB0aGlzLnBsdWdpbi5wZW5kaW5nQ2hhbmdlcy5lbnRyaWVzKCkpeyBpZighcGVuKSBjb250aW51ZTsgY291bnQrKzsgY29uc3Qgcm93PWxpc3QuY3JlYXRlRGl2KHsgY2xzOidnaXRwdWJsaXNoLXJvdycgfSk7IHJvdy5jcmVhdGVTcGFuKHsgdGV4dDpwIH0pOyBjb25zdCBidG49cm93LmNyZWF0ZUVsKCdidXR0b24nLHsgdGV4dDonUHVibGlzaCcgfSk7IGJ0bi5vbmNsaWNrPWFzeW5jKCk9PnsgY29uc3QgZj10aGlzLnBsdWdpbi5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHApOyBpZihmIGluc3RhbmNlb2YgVEZpbGUpeyBhd2FpdCB0aGlzLnBsdWdpbi5xdWV1ZUZpbGVGb3JQdWJsaXNoKGYpOyB0aGlzLnJlbmRlcigpOyB9IH07IH0gaWYoY291bnQ9PT0wKSBsaXN0LmNyZWF0ZURpdih7IHRleHQ6J0tlaW5lIHBlbmRpbmcgRGF0ZWllbi4nIH0pOyBjb25zdCBhY3Rpb25zPWVsLmNyZWF0ZURpdih7IGNsczonZ2l0cHVibGlzaC1hY3Rpb25zJyB9KTsgY29uc3QgYWxsQnRuPWFjdGlvbnMuY3JlYXRlRWwoJ2J1dHRvbicseyB0ZXh0OidBbGxlIHB1Ymxpc2hlbicgfSk7IGFsbEJ0bi5vbmNsaWNrPWFzeW5jKCk9PnsgYXdhaXQgdGhpcy5wbHVnaW4ucHVibGlzaEFsbFBlbmRpbmcoKTsgdGhpcy5yZW5kZXIoKTsgfTsgY29uc3QgdGltZXJzPWVsLmNyZWF0ZURpdih7IGNsczonZ2l0cHVibGlzaC10aW1lcnMnIH0pOyBjb25zdCBub3c9RGF0ZS5ub3coKTsgbGV0IGluYWN0TGVmdD0wOyBpZih0aGlzLnBsdWdpbi5pbmFjdGl2aXR5SGFuZGxlICYmIHRoaXMucGx1Z2luLmxhc3RBY3Rpdml0eVRpbWUpeyBjb25zdCBlbGFwc2VkPW5vdy10aGlzLnBsdWdpbi5sYXN0QWN0aXZpdHlUaW1lOyBpbmFjdExlZnQ9TWF0aC5tYXgoMCwgTWF0aC5yb3VuZCgodGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5hY3Rpdml0eURlbGF5U2VjKjEwMDAgLSBlbGFwc2VkKS8xMDAwKSk7IH0gbGV0IHNlc3NMZWZ0PTA7IGlmKHRoaXMucGx1Z2luLnNlc3Npb25IYW5kbGUgJiYgdGhpcy5wbHVnaW4uc2Vzc2lvblN0YXJ0KXsgY29uc3QgZWxhcHNlZFM9bm93LXRoaXMucGx1Z2luLnNlc3Npb25TdGFydDsgc2Vzc0xlZnQ9TWF0aC5tYXgoMCwgTWF0aC5yb3VuZCgodGhpcy5wbHVnaW4uc2V0dGluZ3MubWF4SW50ZXJ2YWxNaW4qNjAqMTAwMCAtIGVsYXBzZWRTKS8xMDAwKSk7IH0gY29uc3Qgc3RhdD10aW1lcnMuY3JlYXRlRGl2KHsgY2xzOidnaXRwdWJsaXNoLXRpbWVycy1saW5lJyB9KTsgc3RhdC5jcmVhdGVEaXYoeyB0ZXh0OmBTZXNzaW9uIFJlc3Q6ICR7c2Vzc0xlZnR9c2AgfSk7IHN0YXQuY3JlYXRlRGl2KHsgdGV4dDpgSW5ha3Rpdml0XHUwMEU0dCBSZXN0OiAke2luYWN0TGVmdH1zYCB9KTsgaWYodGhpcy5wbHVnaW5bJ2xhc3RTY2FuU3VtbWFyeSddKXsgY29uc3Qgcz10aGlzLnBsdWdpblsnbGFzdFNjYW5TdW1tYXJ5J107IGVsLmNyZWF0ZURpdih7IGNsczonZ2l0cHVibGlzaC1zY2FuLXN1bW1hcnknLCB0ZXh0OmBTY2FuOiAke3MudG90YWx9IHB1Ymxpc2hlZCwgJHtzLm1pc3Npbmd9IGZlaGxlbiwgJHtzLm91dE9mU3luY30gYWJ3ZWljaGVuZCAoJHtuZXcgRGF0ZShzLnRzKS50b0xvY2FsZVRpbWVTdHJpbmcoKX0pYCB9KTsgfSB9XG59XG5cbmNsYXNzIEhlbHBNb2RhbCBleHRlbmRzIE1vZGFsIHsgb25PcGVuKCl7IGNvbnN0IHsgY29udGVudEVsIH09dGhpczsgY29udGVudEVsLmVtcHR5KCk7IGNvbnRlbnRFbC5jcmVhdGVFbCgnaDInLHsgdGV4dDonR2l0IFB1Ymxpc2hlciBIaWxmZScgfSk7IGNvbnRlbnRFbC5jcmVhdGVFbCgncCcseyB0ZXh0OidNYXJraWVyZSBEYXRlaWVuIG1pdCBGcm9udG1hdHRlciBwdWJsaXNoZWQ6dHJ1ZSB1bSBzaWUgYXV0b21hdGlzY2ggenUgdmVyXHUwMEY2ZmZlbnRsaWNoZW4uJyB9KTsgY29udGVudEVsLmNyZWF0ZUVsKCdwJyx7IHRleHQ6J1RpbWVyczogSW5ha3Rpdml0XHUwMEU0dCB2ZXJcdTAwRjZmZmVudGxpY2h0IGVpbiBlaW56ZWxuZXMgRmlsZSwgU2Vzc2lvbiB2ZXJcdTAwRjZmZmVudGxpY2h0IGFsbGUgcGVuZGluZyBEYXRlaWVuIGltIEJhdGNoLicgfSk7IGNvbnRlbnRFbC5jcmVhdGVFbCgncCcseyB0ZXh0OidUb2dnbGUgdW50ZW4gcmVjaHRzOiBHclx1MDBGQ24gPSBzeW5jaHJvbiwgQmxhdSA9IHBlbmRpbmcgXHUwMEM0bmRlcnVuZ2VuLCBSb3QgPSBkZWFrdGl2aWVydC4nIH0pOyBjb250ZW50RWwuY3JlYXRlRWwoJ3AnLHsgdGV4dDonVW5wdWJsaXNoIChwdWJsaXNoZWQ6ZmFsc2UpIGxcdTAwRjZzY2h0IERhdGVpIGF1cyBkZW0gUmVwby4nIH0pOyB9IH1cbiIsICIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlIGEgYm91bmQgdmVyc2lvbiBvZiBhIGZ1bmN0aW9uIHdpdGggYSBzcGVjaWZpZWQgYHRoaXNgIGNvbnRleHRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBiaW5kXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgLSBUaGUgdmFsdWUgdG8gYmUgcGFzc2VkIGFzIHRoZSBgdGhpc2AgcGFyYW1ldGVyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHRoYXQgd2lsbCBjYWxsIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgYHRoaXNgIGNvbnRleHRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBiaW5kIGZyb20gJy4vaGVscGVycy9iaW5kLmpzJztcblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxuY29uc3Qge3RvU3RyaW5nfSA9IE9iamVjdC5wcm90b3R5cGU7XG5jb25zdCB7Z2V0UHJvdG90eXBlT2Z9ID0gT2JqZWN0O1xuY29uc3Qge2l0ZXJhdG9yLCB0b1N0cmluZ1RhZ30gPSBTeW1ib2w7XG5cbmNvbnN0IGtpbmRPZiA9IChjYWNoZSA9PiB0aGluZyA9PiB7XG4gICAgY29uc3Qgc3RyID0gdG9TdHJpbmcuY2FsbCh0aGluZyk7XG4gICAgcmV0dXJuIGNhY2hlW3N0cl0gfHwgKGNhY2hlW3N0cl0gPSBzdHIuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkpO1xufSkoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbmNvbnN0IGtpbmRPZlRlc3QgPSAodHlwZSkgPT4ge1xuICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gKHRoaW5nKSA9PiBraW5kT2YodGhpbmcpID09PSB0eXBlXG59XG5cbmNvbnN0IHR5cGVPZlRlc3QgPSB0eXBlID0+IHRoaW5nID0+IHR5cGVvZiB0aGluZyA9PT0gdHlwZTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IHtpc0FycmF5fSA9IEFycmF5O1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzVW5kZWZpbmVkID0gdHlwZU9mVGVzdCgndW5kZWZpbmVkJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbCkgJiYgdmFsLmNvbnN0cnVjdG9yICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwuY29uc3RydWN0b3IpXG4gICAgJiYgaXNGdW5jdGlvbih2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIpICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzQXJyYXlCdWZmZXIgPSBraW5kT2ZUZXN0KCdBcnJheUJ1ZmZlcicpO1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAoaXNBcnJheUJ1ZmZlcih2YWwuYnVmZmVyKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1N0cmluZyA9IHR5cGVPZlRlc3QoJ3N0cmluZycpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRnVuY3Rpb24gPSB0eXBlT2ZUZXN0KCdmdW5jdGlvbicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzTnVtYmVyID0gdHlwZU9mVGVzdCgnbnVtYmVyJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSB0aGluZyBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzT2JqZWN0ID0gKHRoaW5nKSA9PiB0aGluZyAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQm9vbGVhblxuICpcbiAqIEBwYXJhbSB7Kn0gdGhpbmcgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQm9vbGVhbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzQm9vbGVhbiA9IHRoaW5nID0+IHRoaW5nID09PSB0cnVlIHx8IHRoaW5nID09PSBmYWxzZTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbCkgPT4ge1xuICBpZiAoa2luZE9mKHZhbCkgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgcHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YodmFsKTtcbiAgcmV0dXJuIChwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90b3R5cGUpID09PSBudWxsKSAmJiAhKHRvU3RyaW5nVGFnIGluIHZhbCkgJiYgIShpdGVyYXRvciBpbiB2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIGVtcHR5IG9iamVjdCAoc2FmZWx5IGhhbmRsZXMgQnVmZmVycylcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIGVtcHR5IG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRW1wdHlPYmplY3QgPSAodmFsKSA9PiB7XG4gIC8vIEVhcmx5IHJldHVybiBmb3Igbm9uLW9iamVjdHMgb3IgQnVmZmVycyB0byBwcmV2ZW50IFJhbmdlRXJyb3JcbiAgaWYgKCFpc09iamVjdCh2YWwpIHx8IGlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWwpLmxlbmd0aCA9PT0gMCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIEZhbGxiYWNrIGZvciBhbnkgb3RoZXIgb2JqZWN0cyB0aGF0IG1pZ2h0IGNhdXNlIFJhbmdlRXJyb3Igd2l0aCBPYmplY3Qua2V5cygpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0RhdGUgPSBraW5kT2ZUZXN0KCdEYXRlJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0ZpbGUgPSBraW5kT2ZUZXN0KCdGaWxlJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Jsb2IgPSBraW5kT2ZUZXN0KCdCbG9iJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlTGlzdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGaWxlTGlzdCA9IGtpbmRPZlRlc3QoJ0ZpbGVMaXN0Jyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNTdHJlYW0gPSAodmFsKSA9PiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Zvcm1EYXRhID0gKHRoaW5nKSA9PiB7XG4gIGxldCBraW5kO1xuICByZXR1cm4gdGhpbmcgJiYgKFxuICAgICh0eXBlb2YgRm9ybURhdGEgPT09ICdmdW5jdGlvbicgJiYgdGhpbmcgaW5zdGFuY2VvZiBGb3JtRGF0YSkgfHwgKFxuICAgICAgaXNGdW5jdGlvbih0aGluZy5hcHBlbmQpICYmIChcbiAgICAgICAgKGtpbmQgPSBraW5kT2YodGhpbmcpKSA9PT0gJ2Zvcm1kYXRhJyB8fFxuICAgICAgICAvLyBkZXRlY3QgZm9ybS1kYXRhIGluc3RhbmNlXG4gICAgICAgIChraW5kID09PSAnb2JqZWN0JyAmJiBpc0Z1bmN0aW9uKHRoaW5nLnRvU3RyaW5nKSAmJiB0aGluZy50b1N0cmluZygpID09PSAnW29iamVjdCBGb3JtRGF0YV0nKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNVUkxTZWFyY2hQYXJhbXMgPSBraW5kT2ZUZXN0KCdVUkxTZWFyY2hQYXJhbXMnKTtcblxuY29uc3QgW2lzUmVhZGFibGVTdHJlYW0sIGlzUmVxdWVzdCwgaXNSZXNwb25zZSwgaXNIZWFkZXJzXSA9IFsnUmVhZGFibGVTdHJlYW0nLCAnUmVxdWVzdCcsICdSZXNwb25zZScsICdIZWFkZXJzJ10ubWFwKGtpbmRPZlRlc3QpO1xuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5jb25zdCB0cmltID0gKHN0cikgPT4gc3RyLnRyaW0gP1xuICBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLCAnJyk7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxPd25LZXlzID0gZmFsc2VdXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4sIHthbGxPd25LZXlzID0gZmFsc2V9ID0ge30pIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgaTtcbiAgbGV0IGw7XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEJ1ZmZlciBjaGVja1xuICAgIGlmIChpc0J1ZmZlcihvYmopKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgY29uc3Qga2V5cyA9IGFsbE93bktleXMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopIDogT2JqZWN0LmtleXMob2JqKTtcbiAgICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQga2V5O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kS2V5KG9iaiwga2V5KSB7XG4gIGlmIChpc0J1ZmZlcihvYmopKXtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgbGV0IF9rZXk7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgX2tleSA9IGtleXNbaV07XG4gICAgaWYgKGtleSA9PT0gX2tleS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICByZXR1cm4gX2tleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IF9nbG9iYWwgPSAoKCkgPT4ge1xuICAvKmVzbGludCBuby11bmRlZjowKi9cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZ2xvYmFsVGhpcztcbiAgcmV0dXJuIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbClcbn0pKCk7XG5cbmNvbnN0IGlzQ29udGV4dERlZmluZWQgPSAoY29udGV4dCkgPT4gIWlzVW5kZWZpbmVkKGNvbnRleHQpICYmIGNvbnRleHQgIT09IF9nbG9iYWw7XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgY29uc3Qge2Nhc2VsZXNzLCBza2lwVW5kZWZpbmVkfSA9IGlzQ29udGV4dERlZmluZWQodGhpcykgJiYgdGhpcyB8fCB7fTtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGFzc2lnblZhbHVlID0gKHZhbCwga2V5KSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0S2V5ID0gY2FzZWxlc3MgJiYgZmluZEtleShyZXN1bHQsIGtleSkgfHwga2V5O1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFt0YXJnZXRLZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2UocmVzdWx0W3RhcmdldEtleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIGlmICghc2tpcFVuZGVmaW5lZCB8fCAhaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgcmVzdWx0W3RhcmdldEtleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYXJndW1lbnRzW2ldICYmIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbE93bktleXNdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmNvbnN0IGV4dGVuZCA9IChhLCBiLCB0aGlzQXJnLCB7YWxsT3duS2V5c309IHt9KSA9PiB7XG4gIGZvckVhY2goYiwgKHZhbCwga2V5KSA9PiB7XG4gICAgaWYgKHRoaXNBcmcgJiYgaXNGdW5jdGlvbih2YWwpKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0sIHthbGxPd25LZXlzfSk7XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gY29udGVudCB2YWx1ZSB3aXRob3V0IEJPTVxuICovXG5jb25zdCBzdHJpcEJPTSA9IChjb250ZW50KSA9PiB7XG4gIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBjb250ZW50O1xufVxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcHJvcHNdXG4gKiBAcGFyYW0ge29iamVjdH0gW2Rlc2NyaXB0b3JzXVxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5jb25zdCBpbmhlcml0cyA9IChjb25zdHJ1Y3Rvciwgc3VwZXJDb25zdHJ1Y3RvciwgcHJvcHMsIGRlc2NyaXB0b3JzKSA9PiB7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIGRlc2NyaXB0b3JzKTtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zdHJ1Y3RvciwgJ3N1cGVyJywge1xuICAgIHZhbHVlOiBzdXBlckNvbnN0cnVjdG9yLnByb3RvdHlwZVxuICB9KTtcbiAgcHJvcHMgJiYgT2JqZWN0LmFzc2lnbihjb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIG9iamVjdCB3aXRoIGRlZXAgcHJvdG90eXBlIGNoYWluIHRvIGEgZmxhdCBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VPYmogc291cmNlIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IFtkZXN0T2JqXVxuICogQHBhcmFtIHtGdW5jdGlvbnxCb29sZWFufSBbZmlsdGVyXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Byb3BGaWx0ZXJdXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuY29uc3QgdG9GbGF0T2JqZWN0ID0gKHNvdXJjZU9iaiwgZGVzdE9iaiwgZmlsdGVyLCBwcm9wRmlsdGVyKSA9PiB7XG4gIGxldCBwcm9wcztcbiAgbGV0IGk7XG4gIGxldCBwcm9wO1xuICBjb25zdCBtZXJnZWQgPSB7fTtcblxuICBkZXN0T2JqID0gZGVzdE9iaiB8fCB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gIGlmIChzb3VyY2VPYmogPT0gbnVsbCkgcmV0dXJuIGRlc3RPYmo7XG5cbiAgZG8ge1xuICAgIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlT2JqKTtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAoKCFwcm9wRmlsdGVyIHx8IHByb3BGaWx0ZXIocHJvcCwgc291cmNlT2JqLCBkZXN0T2JqKSkgJiYgIW1lcmdlZFtwcm9wXSkge1xuICAgICAgICBkZXN0T2JqW3Byb3BdID0gc291cmNlT2JqW3Byb3BdO1xuICAgICAgICBtZXJnZWRbcHJvcF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2VPYmogPSBmaWx0ZXIgIT09IGZhbHNlICYmIGdldFByb3RvdHlwZU9mKHNvdXJjZU9iaik7XG4gIH0gd2hpbGUgKHNvdXJjZU9iaiAmJiAoIWZpbHRlciB8fCBmaWx0ZXIoc291cmNlT2JqLCBkZXN0T2JqKSkgJiYgc291cmNlT2JqICE9PSBPYmplY3QucHJvdG90eXBlKTtcblxuICByZXR1cm4gZGVzdE9iajtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzdHJpbmcgZW5kcyB3aXRoIHRoZSBjaGFyYWN0ZXJzIG9mIGEgc3BlY2lmaWVkIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb249IDBdXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGVuZHNXaXRoID0gKHN0ciwgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikgPT4ge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24gPiBzdHIubGVuZ3RoKSB7XG4gICAgcG9zaXRpb24gPSBzdHIubGVuZ3RoO1xuICB9XG4gIHBvc2l0aW9uIC09IHNlYXJjaFN0cmluZy5sZW5ndGg7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHN0ci5pbmRleE9mKHNlYXJjaFN0cmluZywgcG9zaXRpb24pO1xuICByZXR1cm4gbGFzdEluZGV4ICE9PSAtMSAmJiBsYXN0SW5kZXggPT09IHBvc2l0aW9uO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBuZXcgYXJyYXkgZnJvbSBhcnJheSBsaWtlIG9iamVjdCBvciBudWxsIGlmIGZhaWxlZFxuICpcbiAqIEBwYXJhbSB7Kn0gW3RoaW5nXVxuICpcbiAqIEByZXR1cm5zIHs/QXJyYXl9XG4gKi9cbmNvbnN0IHRvQXJyYXkgPSAodGhpbmcpID0+IHtcbiAgaWYgKCF0aGluZykgcmV0dXJuIG51bGw7XG4gIGlmIChpc0FycmF5KHRoaW5nKSkgcmV0dXJuIHRoaW5nO1xuICBsZXQgaSA9IHRoaW5nLmxlbmd0aDtcbiAgaWYgKCFpc051bWJlcihpKSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGFyciA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBhcnJbaV0gPSB0aGluZ1tpXTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vKipcbiAqIENoZWNraW5nIGlmIHRoZSBVaW50OEFycmF5IGV4aXN0cyBhbmQgaWYgaXQgZG9lcywgaXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZVxuICogdGhpbmcgcGFzc2VkIGluIGlzIGFuIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXlcbiAqXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9XG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuY29uc3QgaXNUeXBlZEFycmF5ID0gKFR5cGVkQXJyYXkgPT4ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICByZXR1cm4gdGhpbmcgPT4ge1xuICAgIHJldHVybiBUeXBlZEFycmF5ICYmIHRoaW5nIGluc3RhbmNlb2YgVHlwZWRBcnJheTtcbiAgfTtcbn0pKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBnZXRQcm90b3R5cGVPZihVaW50OEFycmF5KSk7XG5cbi8qKlxuICogRm9yIGVhY2ggZW50cnkgaW4gdGhlIG9iamVjdCwgY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB0aGUga2V5IGFuZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdDxhbnksIGFueT59IG9iaiAtIFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBlbnRyeS5cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuY29uc3QgZm9yRWFjaEVudHJ5ID0gKG9iaiwgZm4pID0+IHtcbiAgY29uc3QgZ2VuZXJhdG9yID0gb2JqICYmIG9ialtpdGVyYXRvcl07XG5cbiAgY29uc3QgX2l0ZXJhdG9yID0gZ2VuZXJhdG9yLmNhbGwob2JqKTtcblxuICBsZXQgcmVzdWx0O1xuXG4gIHdoaWxlICgocmVzdWx0ID0gX2l0ZXJhdG9yLm5leHQoKSkgJiYgIXJlc3VsdC5kb25lKSB7XG4gICAgY29uc3QgcGFpciA9IHJlc3VsdC52YWx1ZTtcbiAgICBmbi5jYWxsKG9iaiwgcGFpclswXSwgcGFpclsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhbmQgYSBzdHJpbmcsIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgbWF0Y2hlc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdFeHAgLSBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIGFnYWluc3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBzZWFyY2guXG4gKlxuICogQHJldHVybnMge0FycmF5PGJvb2xlYW4+fVxuICovXG5jb25zdCBtYXRjaEFsbCA9IChyZWdFeHAsIHN0cikgPT4ge1xuICBsZXQgbWF0Y2hlcztcbiAgY29uc3QgYXJyID0gW107XG5cbiAgd2hpbGUgKChtYXRjaGVzID0gcmVnRXhwLmV4ZWMoc3RyKSkgIT09IG51bGwpIHtcbiAgICBhcnIucHVzaChtYXRjaGVzKTtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59XG5cbi8qIENoZWNraW5nIGlmIHRoZSBraW5kT2ZUZXN0IGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB3aGVuIHBhc3NlZCBhbiBIVE1MRm9ybUVsZW1lbnQuICovXG5jb25zdCBpc0hUTUxGb3JtID0ga2luZE9mVGVzdCgnSFRNTEZvcm1FbGVtZW50Jyk7XG5cbmNvbnN0IHRvQ2FtZWxDYXNlID0gc3RyID0+IHtcbiAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX1xcc10oW2EtelxcZF0pKFxcdyopL2csXG4gICAgZnVuY3Rpb24gcmVwbGFjZXIobSwgcDEsIHAyKSB7XG4gICAgICByZXR1cm4gcDEudG9VcHBlckNhc2UoKSArIHAyO1xuICAgIH1cbiAgKTtcbn07XG5cbi8qIENyZWF0aW5nIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGNoZWNrIGlmIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eS4gKi9cbmNvbnN0IGhhc093blByb3BlcnR5ID0gKCh7aGFzT3duUHJvcGVydHl9KSA9PiAob2JqLCBwcm9wKSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpKE9iamVjdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNSZWdFeHAgPSBraW5kT2ZUZXN0KCdSZWdFeHAnKTtcblxuY29uc3QgcmVkdWNlRGVzY3JpcHRvcnMgPSAob2JqLCByZWR1Y2VyKSA9PiB7XG4gIGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKTtcbiAgY29uc3QgcmVkdWNlZERlc2NyaXB0b3JzID0ge307XG5cbiAgZm9yRWFjaChkZXNjcmlwdG9ycywgKGRlc2NyaXB0b3IsIG5hbWUpID0+IHtcbiAgICBsZXQgcmV0O1xuICAgIGlmICgocmV0ID0gcmVkdWNlcihkZXNjcmlwdG9yLCBuYW1lLCBvYmopKSAhPT0gZmFsc2UpIHtcbiAgICAgIHJlZHVjZWREZXNjcmlwdG9yc1tuYW1lXSA9IHJldCB8fCBkZXNjcmlwdG9yO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqLCByZWR1Y2VkRGVzY3JpcHRvcnMpO1xufVxuXG4vKipcbiAqIE1ha2VzIGFsbCBtZXRob2RzIHJlYWQtb25seVxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICovXG5cbmNvbnN0IGZyZWV6ZU1ldGhvZHMgPSAob2JqKSA9PiB7XG4gIHJlZHVjZURlc2NyaXB0b3JzKG9iaiwgKGRlc2NyaXB0b3IsIG5hbWUpID0+IHtcbiAgICAvLyBza2lwIHJlc3RyaWN0ZWQgcHJvcHMgaW4gc3RyaWN0IG1vZGVcbiAgICBpZiAoaXNGdW5jdGlvbihvYmopICYmIFsnYXJndW1lbnRzJywgJ2NhbGxlcicsICdjYWxsZWUnXS5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gb2JqW25hbWVdO1xuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAoJ3dyaXRhYmxlJyBpbiBkZXNjcmlwdG9yKSB7XG4gICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFkZXNjcmlwdG9yLnNldCkge1xuICAgICAgZGVzY3JpcHRvci5zZXQgPSAoKSA9PiB7XG4gICAgICAgIHRocm93IEVycm9yKCdDYW4gbm90IHJld3JpdGUgcmVhZC1vbmx5IG1ldGhvZCBcXCcnICsgbmFtZSArICdcXCcnKTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3QgdG9PYmplY3RTZXQgPSAoYXJyYXlPclN0cmluZywgZGVsaW1pdGVyKSA9PiB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuXG4gIGNvbnN0IGRlZmluZSA9IChhcnIpID0+IHtcbiAgICBhcnIuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICBvYmpbdmFsdWVdID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIGlzQXJyYXkoYXJyYXlPclN0cmluZykgPyBkZWZpbmUoYXJyYXlPclN0cmluZykgOiBkZWZpbmUoU3RyaW5nKGFycmF5T3JTdHJpbmcpLnNwbGl0KGRlbGltaXRlcikpO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fVxuXG5jb25zdCB0b0Zpbml0ZU51bWJlciA9ICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSA9ICt2YWx1ZSkgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbn1cblxuXG5cbi8qKlxuICogSWYgdGhlIHRoaW5nIGlzIGEgRm9ybURhdGEgb2JqZWN0LCByZXR1cm4gdHJ1ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IHRoaW5nIC0gVGhlIHRoaW5nIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1NwZWNDb21wbGlhbnRGb3JtKHRoaW5nKSB7XG4gIHJldHVybiAhISh0aGluZyAmJiBpc0Z1bmN0aW9uKHRoaW5nLmFwcGVuZCkgJiYgdGhpbmdbdG9TdHJpbmdUYWddID09PSAnRm9ybURhdGEnICYmIHRoaW5nW2l0ZXJhdG9yXSk7XG59XG5cbmNvbnN0IHRvSlNPTk9iamVjdCA9IChvYmopID0+IHtcbiAgY29uc3Qgc3RhY2sgPSBuZXcgQXJyYXkoMTApO1xuXG4gIGNvbnN0IHZpc2l0ID0gKHNvdXJjZSwgaSkgPT4ge1xuXG4gICAgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIGlmIChzdGFjay5pbmRleE9mKHNvdXJjZSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vQnVmZmVyIGNoZWNrXG4gICAgICBpZiAoaXNCdWZmZXIoc291cmNlKSkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgfVxuXG4gICAgICBpZighKCd0b0pTT04nIGluIHNvdXJjZSkpIHtcbiAgICAgICAgc3RhY2tbaV0gPSBzb3VyY2U7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGlzQXJyYXkoc291cmNlKSA/IFtdIDoge307XG5cbiAgICAgICAgZm9yRWFjaChzb3VyY2UsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVkdWNlZFZhbHVlID0gdmlzaXQodmFsdWUsIGkgKyAxKTtcbiAgICAgICAgICAhaXNVbmRlZmluZWQocmVkdWNlZFZhbHVlKSAmJiAodGFyZ2V0W2tleV0gPSByZWR1Y2VkVmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzdGFja1tpXSA9IHVuZGVmaW5lZDtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICByZXR1cm4gdmlzaXQob2JqLCAwKTtcbn1cblxuY29uc3QgaXNBc3luY0ZuID0ga2luZE9mVGVzdCgnQXN5bmNGdW5jdGlvbicpO1xuXG5jb25zdCBpc1RoZW5hYmxlID0gKHRoaW5nKSA9PlxuICB0aGluZyAmJiAoaXNPYmplY3QodGhpbmcpIHx8IGlzRnVuY3Rpb24odGhpbmcpKSAmJiBpc0Z1bmN0aW9uKHRoaW5nLnRoZW4pICYmIGlzRnVuY3Rpb24odGhpbmcuY2F0Y2gpO1xuXG4vLyBvcmlnaW5hbCBjb2RlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vRGlnaXRhbEJyYWluSlMvQXhpb3NQcm9taXNlL2Jsb2IvMTZkZWFiMTM3MTBlYzA5Nzc5OTIyMTMxZjNmYTU5NTQzMjBmODNhYi9saWIvdXRpbHMuanMjTDExLUwzNFxuXG5jb25zdCBfc2V0SW1tZWRpYXRlID0gKChzZXRJbW1lZGlhdGVTdXBwb3J0ZWQsIHBvc3RNZXNzYWdlU3VwcG9ydGVkKSA9PiB7XG4gIGlmIChzZXRJbW1lZGlhdGVTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gc2V0SW1tZWRpYXRlO1xuICB9XG5cbiAgcmV0dXJuIHBvc3RNZXNzYWdlU3VwcG9ydGVkID8gKCh0b2tlbiwgY2FsbGJhY2tzKSA9PiB7XG4gICAgX2dsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoe3NvdXJjZSwgZGF0YX0pID0+IHtcbiAgICAgIGlmIChzb3VyY2UgPT09IF9nbG9iYWwgJiYgZGF0YSA9PT0gdG9rZW4pIHtcbiAgICAgICAgY2FsbGJhY2tzLmxlbmd0aCAmJiBjYWxsYmFja3Muc2hpZnQoKSgpO1xuICAgICAgfVxuICAgIH0sIGZhbHNlKTtcblxuICAgIHJldHVybiAoY2IpID0+IHtcbiAgICAgIGNhbGxiYWNrcy5wdXNoKGNiKTtcbiAgICAgIF9nbG9iYWwucG9zdE1lc3NhZ2UodG9rZW4sIFwiKlwiKTtcbiAgICB9XG4gIH0pKGBheGlvc0Ake01hdGgucmFuZG9tKCl9YCwgW10pIDogKGNiKSA9PiBzZXRUaW1lb3V0KGNiKTtcbn0pKFxuICB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nLFxuICBpc0Z1bmN0aW9uKF9nbG9iYWwucG9zdE1lc3NhZ2UpXG4pO1xuXG5jb25zdCBhc2FwID0gdHlwZW9mIHF1ZXVlTWljcm90YXNrICE9PSAndW5kZWZpbmVkJyA/XG4gIHF1ZXVlTWljcm90YXNrLmJpbmQoX2dsb2JhbCkgOiAoIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5leHRUaWNrIHx8IF9zZXRJbW1lZGlhdGUpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKipcblxuXG5jb25zdCBpc0l0ZXJhYmxlID0gKHRoaW5nKSA9PiB0aGluZyAhPSBudWxsICYmIGlzRnVuY3Rpb24odGhpbmdbaXRlcmF0b3JdKTtcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmcsXG4gIGlzTnVtYmVyLFxuICBpc0Jvb2xlYW4sXG4gIGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0LFxuICBpc0VtcHR5T2JqZWN0LFxuICBpc1JlYWRhYmxlU3RyZWFtLFxuICBpc1JlcXVlc3QsXG4gIGlzUmVzcG9uc2UsXG4gIGlzSGVhZGVycyxcbiAgaXNVbmRlZmluZWQsXG4gIGlzRGF0ZSxcbiAgaXNGaWxlLFxuICBpc0Jsb2IsXG4gIGlzUmVnRXhwLFxuICBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzVHlwZWRBcnJheSxcbiAgaXNGaWxlTGlzdCxcbiAgZm9yRWFjaCxcbiAgbWVyZ2UsXG4gIGV4dGVuZCxcbiAgdHJpbSxcbiAgc3RyaXBCT00sXG4gIGluaGVyaXRzLFxuICB0b0ZsYXRPYmplY3QsXG4gIGtpbmRPZixcbiAga2luZE9mVGVzdCxcbiAgZW5kc1dpdGgsXG4gIHRvQXJyYXksXG4gIGZvckVhY2hFbnRyeSxcbiAgbWF0Y2hBbGwsXG4gIGlzSFRNTEZvcm0sXG4gIGhhc093blByb3BlcnR5LFxuICBoYXNPd25Qcm9wOiBoYXNPd25Qcm9wZXJ0eSwgLy8gYW4gYWxpYXMgdG8gYXZvaWQgRVNMaW50IG5vLXByb3RvdHlwZS1idWlsdGlucyBkZXRlY3Rpb25cbiAgcmVkdWNlRGVzY3JpcHRvcnMsXG4gIGZyZWV6ZU1ldGhvZHMsXG4gIHRvT2JqZWN0U2V0LFxuICB0b0NhbWVsQ2FzZSxcbiAgbm9vcCxcbiAgdG9GaW5pdGVOdW1iZXIsXG4gIGZpbmRLZXksXG4gIGdsb2JhbDogX2dsb2JhbCxcbiAgaXNDb250ZXh0RGVmaW5lZCxcbiAgaXNTcGVjQ29tcGxpYW50Rm9ybSxcbiAgdG9KU09OT2JqZWN0LFxuICBpc0FzeW5jRm4sXG4gIGlzVGhlbmFibGUsXG4gIHNldEltbWVkaWF0ZTogX3NldEltbWVkaWF0ZSxcbiAgYXNhcCxcbiAgaXNJdGVyYWJsZVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5mdW5jdGlvbiBBeGlvc0Vycm9yKG1lc3NhZ2UsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgRXJyb3IuY2FsbCh0aGlzKTtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcbiAgfVxuXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMubmFtZSA9ICdBeGlvc0Vycm9yJztcbiAgY29kZSAmJiAodGhpcy5jb2RlID0gY29kZSk7XG4gIGNvbmZpZyAmJiAodGhpcy5jb25maWcgPSBjb25maWcpO1xuICByZXF1ZXN0ICYmICh0aGlzLnJlcXVlc3QgPSByZXF1ZXN0KTtcbiAgaWYgKHJlc3BvbnNlKSB7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzID8gcmVzcG9uc2Uuc3RhdHVzIDogbnVsbDtcbiAgfVxufVxuXG51dGlscy5pbmhlcml0cyhBeGlvc0Vycm9yLCBFcnJvciwge1xuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gU3RhbmRhcmRcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIC8vIE1pY3Jvc29mdFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBudW1iZXI6IHRoaXMubnVtYmVyLFxuICAgICAgLy8gTW96aWxsYVxuICAgICAgZmlsZU5hbWU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG4gICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICAvLyBBeGlvc1xuICAgICAgY29uZmlnOiB1dGlscy50b0pTT05PYmplY3QodGhpcy5jb25maWcpLFxuICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1c1xuICAgIH07XG4gIH1cbn0pO1xuXG5jb25zdCBwcm90b3R5cGUgPSBBeGlvc0Vycm9yLnByb3RvdHlwZTtcbmNvbnN0IGRlc2NyaXB0b3JzID0ge307XG5cbltcbiAgJ0VSUl9CQURfT1BUSU9OX1ZBTFVFJyxcbiAgJ0VSUl9CQURfT1BUSU9OJyxcbiAgJ0VDT05OQUJPUlRFRCcsXG4gICdFVElNRURPVVQnLFxuICAnRVJSX05FVFdPUksnLFxuICAnRVJSX0ZSX1RPT19NQU5ZX1JFRElSRUNUUycsXG4gICdFUlJfREVQUkVDQVRFRCcsXG4gICdFUlJfQkFEX1JFU1BPTlNFJyxcbiAgJ0VSUl9CQURfUkVRVUVTVCcsXG4gICdFUlJfQ0FOQ0VMRUQnLFxuICAnRVJSX05PVF9TVVBQT1JUJyxcbiAgJ0VSUl9JTlZBTElEX1VSTCdcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5dLmZvckVhY2goY29kZSA9PiB7XG4gIGRlc2NyaXB0b3JzW2NvZGVdID0ge3ZhbHVlOiBjb2RlfTtcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBeGlvc0Vycm9yLCBkZXNjcmlwdG9ycyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAnaXNBeGlvc0Vycm9yJywge3ZhbHVlOiB0cnVlfSk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5BeGlvc0Vycm9yLmZyb20gPSAoZXJyb3IsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UsIGN1c3RvbVByb3BzKSA9PiB7XG4gIGNvbnN0IGF4aW9zRXJyb3IgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG5cbiAgdXRpbHMudG9GbGF0T2JqZWN0KGVycm9yLCBheGlvc0Vycm9yLCBmdW5jdGlvbiBmaWx0ZXIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gRXJyb3IucHJvdG90eXBlO1xuICB9LCBwcm9wID0+IHtcbiAgICByZXR1cm4gcHJvcCAhPT0gJ2lzQXhpb3NFcnJvcic7XG4gIH0pO1xuXG4gIGNvbnN0IG1zZyA9IGVycm9yICYmIGVycm9yLm1lc3NhZ2UgPyBlcnJvci5tZXNzYWdlIDogJ0Vycm9yJztcblxuICAvLyBQcmVmZXIgZXhwbGljaXQgY29kZTsgb3RoZXJ3aXNlIGNvcHkgdGhlIGxvdy1sZXZlbCBlcnJvcidzIGNvZGUgKGUuZy4gRUNPTk5SRUZVU0VEKVxuICBjb25zdCBlcnJDb2RlID0gY29kZSA9PSBudWxsICYmIGVycm9yID8gZXJyb3IuY29kZSA6IGNvZGU7XG4gIEF4aW9zRXJyb3IuY2FsbChheGlvc0Vycm9yLCBtc2csIGVyckNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UpO1xuXG4gIC8vIENoYWluIHRoZSBvcmlnaW5hbCBlcnJvciBvbiB0aGUgc3RhbmRhcmQgZmllbGQ7IG5vbi1lbnVtZXJhYmxlIHRvIGF2b2lkIEpTT04gbm9pc2VcbiAgaWYgKGVycm9yICYmIGF4aW9zRXJyb3IuY2F1c2UgPT0gbnVsbCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShheGlvc0Vycm9yLCAnY2F1c2UnLCB7IHZhbHVlOiBlcnJvciwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICB9XG5cbiAgYXhpb3NFcnJvci5uYW1lID0gKGVycm9yICYmIGVycm9yLm5hbWUpIHx8ICdFcnJvcic7XG5cbiAgY3VzdG9tUHJvcHMgJiYgT2JqZWN0LmFzc2lnbihheGlvc0Vycm9yLCBjdXN0b21Qcm9wcyk7XG5cbiAgcmV0dXJuIGF4aW9zRXJyb3I7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBeGlvc0Vycm9yO1xuIiwgIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzdHJpY3RcbmV4cG9ydCBkZWZhdWx0IG51bGw7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbi8vIHRlbXBvcmFyeSBob3RmaXggdG8gYXZvaWQgY2lyY3VsYXIgcmVmZXJlbmNlcyB1bnRpbCBBeGlvc1VSTFNlYXJjaFBhcmFtcyBpcyByZWZhY3RvcmVkXG5pbXBvcnQgUGxhdGZvcm1Gb3JtRGF0YSBmcm9tICcuLi9wbGF0Zm9ybS9ub2RlL2NsYXNzZXMvRm9ybURhdGEuanMnO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIHRoaW5nIGlzIGEgYXJyYXkgb3IganMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aGluZyAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgdmlzaXRlZC5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWaXNpdGFibGUodGhpbmcpIHtcbiAgcmV0dXJuIHV0aWxzLmlzUGxhaW5PYmplY3QodGhpbmcpIHx8IHV0aWxzLmlzQXJyYXkodGhpbmcpO1xufVxuXG4vKipcbiAqIEl0IHJlbW92ZXMgdGhlIGJyYWNrZXRzIGZyb20gdGhlIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBwYXJhbWV0ZXIuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGtleSB3aXRob3V0IHRoZSBicmFja2V0cy5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQnJhY2tldHMoa2V5KSB7XG4gIHJldHVybiB1dGlscy5lbmRzV2l0aChrZXksICdbXScpID8ga2V5LnNsaWNlKDAsIC0yKSA6IGtleTtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHBhdGgsIGEga2V5LCBhbmQgYSBib29sZWFuLCBhbmQgcmV0dXJucyBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIHBhdGggdG8gdGhlIGN1cnJlbnQga2V5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGJlaW5nIGl0ZXJhdGVkIG92ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gZG90cyAtIElmIHRydWUsIHRoZSBrZXkgd2lsbCBiZSByZW5kZXJlZCB3aXRoIGRvdHMgaW5zdGVhZCBvZiBicmFja2V0cy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcGF0aCB0byB0aGUgY3VycmVudCBrZXkuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlcktleShwYXRoLCBrZXksIGRvdHMpIHtcbiAgaWYgKCFwYXRoKSByZXR1cm4ga2V5O1xuICByZXR1cm4gcGF0aC5jb25jYXQoa2V5KS5tYXAoZnVuY3Rpb24gZWFjaCh0b2tlbiwgaSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHRva2VuID0gcmVtb3ZlQnJhY2tldHModG9rZW4pO1xuICAgIHJldHVybiAhZG90cyAmJiBpID8gJ1snICsgdG9rZW4gKyAnXScgOiB0b2tlbjtcbiAgfSkuam9pbihkb3RzID8gJy4nIDogJycpO1xufVxuXG4vKipcbiAqIElmIHRoZSBhcnJheSBpcyBhbiBhcnJheSBhbmQgbm9uZSBvZiBpdHMgZWxlbWVudHMgYXJlIHZpc2l0YWJsZSwgdGhlbiBpdCdzIGEgZmxhdCBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IGFyciAtIFRoZSBhcnJheSB0byBjaGVja1xuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZsYXRBcnJheShhcnIpIHtcbiAgcmV0dXJuIHV0aWxzLmlzQXJyYXkoYXJyKSAmJiAhYXJyLnNvbWUoaXNWaXNpdGFibGUpO1xufVxuXG5jb25zdCBwcmVkaWNhdGVzID0gdXRpbHMudG9GbGF0T2JqZWN0KHV0aWxzLCB7fSwgbnVsbCwgZnVuY3Rpb24gZmlsdGVyKHByb3ApIHtcbiAgcmV0dXJuIC9eaXNbQS1aXS8udGVzdChwcm9wKTtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSBkYXRhIG9iamVjdCB0byBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7P09iamVjdH0gW2Zvcm1EYXRhXVxuICogQHBhcmFtIHs/T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnZpc2l0b3JdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1ldGFUb2tlbnMgPSB0cnVlXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kb3RzID0gZmFsc2VdXG4gKiBAcGFyYW0gez9Cb29sZWFufSBbb3B0aW9ucy5pbmRleGVzID0gZmFsc2VdXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqKi9cblxuLyoqXG4gKiBJdCBjb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIEZvcm1EYXRhIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PGFueSwgYW55Pn0gb2JqIC0gVGhlIG9iamVjdCB0byBjb252ZXJ0IHRvIGZvcm0gZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtRGF0YSAtIFRoZSBGb3JtRGF0YSBvYmplY3QgdG8gYXBwZW5kIHRvLlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBvcHRpb25zXG4gKlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gdG9Gb3JtRGF0YShvYmosIGZvcm1EYXRhLCBvcHRpb25zKSB7XG4gIGlmICghdXRpbHMuaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGZvcm1EYXRhID0gZm9ybURhdGEgfHwgbmV3IChQbGF0Zm9ybUZvcm1EYXRhIHx8IEZvcm1EYXRhKSgpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBvcHRpb25zID0gdXRpbHMudG9GbGF0T2JqZWN0KG9wdGlvbnMsIHtcbiAgICBtZXRhVG9rZW5zOiB0cnVlLFxuICAgIGRvdHM6IGZhbHNlLFxuICAgIGluZGV4ZXM6IGZhbHNlXG4gIH0sIGZhbHNlLCBmdW5jdGlvbiBkZWZpbmVkKG9wdGlvbiwgc291cmNlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gICAgcmV0dXJuICF1dGlscy5pc1VuZGVmaW5lZChzb3VyY2Vbb3B0aW9uXSk7XG4gIH0pO1xuXG4gIGNvbnN0IG1ldGFUb2tlbnMgPSBvcHRpb25zLm1ldGFUb2tlbnM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICBjb25zdCB2aXNpdG9yID0gb3B0aW9ucy52aXNpdG9yIHx8IGRlZmF1bHRWaXNpdG9yO1xuICBjb25zdCBkb3RzID0gb3B0aW9ucy5kb3RzO1xuICBjb25zdCBpbmRleGVzID0gb3B0aW9ucy5pbmRleGVzO1xuICBjb25zdCBfQmxvYiA9IG9wdGlvbnMuQmxvYiB8fCB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgQmxvYjtcbiAgY29uc3QgdXNlQmxvYiA9IF9CbG9iICYmIHV0aWxzLmlzU3BlY0NvbXBsaWFudEZvcm0oZm9ybURhdGEpO1xuXG4gIGlmICghdXRpbHMuaXNGdW5jdGlvbih2aXNpdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Zpc2l0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb252ZXJ0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiAnJztcblxuICAgIGlmICh1dGlscy5pc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9JU09TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNCb29sZWFuKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKCF1c2VCbG9iICYmIHV0aWxzLmlzQmxvYih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdCbG9iIGlzIG5vdCBzdXBwb3J0ZWQuIFVzZSBhIEJ1ZmZlciBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyKHZhbHVlKSB8fCB1dGlscy5pc1R5cGVkQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdXNlQmxvYiAmJiB0eXBlb2YgQmxvYiA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBCbG9iKFt2YWx1ZV0pIDogQnVmZmVyLmZyb20odmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHZpc2l0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBrZXlcbiAgICogQHBhcmFtIHtBcnJheTxTdHJpbmd8TnVtYmVyPn0gcGF0aFxuICAgKiBAdGhpcyB7Rm9ybURhdGF9XG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSByZXR1cm4gdHJ1ZSB0byB2aXNpdCB0aGUgZWFjaCBwcm9wIG9mIHRoZSB2YWx1ZSByZWN1cnNpdmVseVxuICAgKi9cbiAgZnVuY3Rpb24gZGVmYXVsdFZpc2l0b3IodmFsdWUsIGtleSwgcGF0aCkge1xuICAgIGxldCBhcnIgPSB2YWx1ZTtcblxuICAgIGlmICh2YWx1ZSAmJiAhcGF0aCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAodXRpbHMuZW5kc1dpdGgoa2V5LCAne30nKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAga2V5ID0gbWV0YVRva2VucyA/IGtleSA6IGtleS5zbGljZSgwLCAtMik7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICh1dGlscy5pc0FycmF5KHZhbHVlKSAmJiBpc0ZsYXRBcnJheSh2YWx1ZSkpIHx8XG4gICAgICAgICgodXRpbHMuaXNGaWxlTGlzdCh2YWx1ZSkgfHwgdXRpbHMuZW5kc1dpdGgoa2V5LCAnW10nKSkgJiYgKGFyciA9IHV0aWxzLnRvQXJyYXkodmFsdWUpKVxuICAgICAgICApKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBrZXkgPSByZW1vdmVCcmFja2V0cyhrZXkpO1xuXG4gICAgICAgIGFyci5mb3JFYWNoKGZ1bmN0aW9uIGVhY2goZWwsIGluZGV4KSB7XG4gICAgICAgICAgISh1dGlscy5pc1VuZGVmaW5lZChlbCkgfHwgZWwgPT09IG51bGwpICYmIGZvcm1EYXRhLmFwcGVuZChcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgaW5kZXhlcyA9PT0gdHJ1ZSA/IHJlbmRlcktleShba2V5XSwgaW5kZXgsIGRvdHMpIDogKGluZGV4ZXMgPT09IG51bGwgPyBrZXkgOiBrZXkgKyAnW10nKSxcbiAgICAgICAgICAgIGNvbnZlcnRWYWx1ZShlbClcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1Zpc2l0YWJsZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZvcm1EYXRhLmFwcGVuZChyZW5kZXJLZXkocGF0aCwga2V5LCBkb3RzKSwgY29udmVydFZhbHVlKHZhbHVlKSk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBzdGFjayA9IFtdO1xuXG4gIGNvbnN0IGV4cG9zZWRIZWxwZXJzID0gT2JqZWN0LmFzc2lnbihwcmVkaWNhdGVzLCB7XG4gICAgZGVmYXVsdFZpc2l0b3IsXG4gICAgY29udmVydFZhbHVlLFxuICAgIGlzVmlzaXRhYmxlXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGJ1aWxkKHZhbHVlLCBwYXRoKSB7XG4gICAgaWYgKHV0aWxzLmlzVW5kZWZpbmVkKHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgaWYgKHN0YWNrLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0NpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3RlZCBpbiAnICsgcGF0aC5qb2luKCcuJykpO1xuICAgIH1cblxuICAgIHN0YWNrLnB1c2godmFsdWUpO1xuXG4gICAgdXRpbHMuZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gZWFjaChlbCwga2V5KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSAhKHV0aWxzLmlzVW5kZWZpbmVkKGVsKSB8fCBlbCA9PT0gbnVsbCkgJiYgdmlzaXRvci5jYWxsKFxuICAgICAgICBmb3JtRGF0YSwgZWwsIHV0aWxzLmlzU3RyaW5nKGtleSkgPyBrZXkudHJpbSgpIDoga2V5LCBwYXRoLCBleHBvc2VkSGVscGVyc1xuICAgICAgKTtcblxuICAgICAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICBidWlsZChlbCwgcGF0aCA/IHBhdGguY29uY2F0KGtleSkgOiBba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzdGFjay5wb3AoKTtcbiAgfVxuXG4gIGlmICghdXRpbHMuaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RhdGEgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuXG4gIGJ1aWxkKG9iaik7XG5cbiAgcmV0dXJuIGZvcm1EYXRhO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b0Zvcm1EYXRhO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi90b0Zvcm1EYXRhLmpzJztcblxuLyoqXG4gKiBJdCBlbmNvZGVzIGEgc3RyaW5nIGJ5IHJlcGxhY2luZyBhbGwgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgaW4gdGhlIHVucmVzZXJ2ZWQgc2V0IHdpdGhcbiAqIHRoZWlyIHBlcmNlbnQtZW5jb2RlZCBlcXVpdmFsZW50c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIGVuY29kZS5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShzdHIpIHtcbiAgY29uc3QgY2hhck1hcCA9IHtcbiAgICAnISc6ICclMjEnLFxuICAgIFwiJ1wiOiAnJTI3JyxcbiAgICAnKCc6ICclMjgnLFxuICAgICcpJzogJyUyOScsXG4gICAgJ34nOiAnJTdFJyxcbiAgICAnJTIwJzogJysnLFxuICAgICclMDAnOiAnXFx4MDAnXG4gIH07XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9bIScoKX5dfCUyMHwlMDAvZywgZnVuY3Rpb24gcmVwbGFjZXIobWF0Y2gpIHtcbiAgICByZXR1cm4gY2hhck1hcFttYXRjaF07XG4gIH0pO1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgcGFyYW1zIG9iamVjdCBhbmQgY29udmVydHMgaXQgdG8gYSBGb3JtRGF0YSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIHRvIGJlIGNvbnZlcnRlZCB0byBhIEZvcm1EYXRhIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBwYXNzZWQgdG8gdGhlIEF4aW9zIGNvbnN0cnVjdG9yLlxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBBeGlvc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgdGhpcy5fcGFpcnMgPSBbXTtcblxuICBwYXJhbXMgJiYgdG9Gb3JtRGF0YShwYXJhbXMsIHRoaXMsIG9wdGlvbnMpO1xufVxuXG5jb25zdCBwcm90b3R5cGUgPSBBeGlvc1VSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQobmFtZSwgdmFsdWUpIHtcbiAgdGhpcy5fcGFpcnMucHVzaChbbmFtZSwgdmFsdWVdKTtcbn07XG5cbnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGVuY29kZXIpIHtcbiAgY29uc3QgX2VuY29kZSA9IGVuY29kZXIgPyBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBlbmNvZGVyLmNhbGwodGhpcywgdmFsdWUsIGVuY29kZSk7XG4gIH0gOiBlbmNvZGU7XG5cbiAgcmV0dXJuIHRoaXMuX3BhaXJzLm1hcChmdW5jdGlvbiBlYWNoKHBhaXIpIHtcbiAgICByZXR1cm4gX2VuY29kZShwYWlyWzBdKSArICc9JyArIF9lbmNvZGUocGFpclsxXSk7XG4gIH0sICcnKS5qb2luKCcmJyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBeGlvc1VSTFNlYXJjaFBhcmFtcztcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgQXhpb3NVUkxTZWFyY2hQYXJhbXMgZnJvbSAnLi4vaGVscGVycy9BeGlvc1VSTFNlYXJjaFBhcmFtcy5qcyc7XG5cbi8qKlxuICogSXQgcmVwbGFjZXMgYWxsIGluc3RhbmNlcyBvZiB0aGUgY2hhcmFjdGVycyBgOmAsIGAkYCwgYCxgLCBgK2AsIGBbYCwgYW5kIGBdYCB3aXRoIHRoZWlyXG4gKiBVUkkgZW5jb2RlZCBjb3VudGVycGFydHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsIFRoZSB2YWx1ZSB0byBiZSBlbmNvZGVkLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBlbmNvZGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEBwYXJhbSB7PyhvYmplY3R8RnVuY3Rpb24pfSBvcHRpb25zXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBcbiAgY29uc3QgX2VuY29kZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5lbmNvZGUgfHwgZW5jb2RlO1xuXG4gIGlmICh1dGlscy5pc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHNlcmlhbGl6ZTogb3B0aW9uc1xuICAgIH07XG4gIH0gXG5cbiAgY29uc3Qgc2VyaWFsaXplRm4gPSBvcHRpb25zICYmIG9wdGlvbnMuc2VyaWFsaXplO1xuXG4gIGxldCBzZXJpYWxpemVkUGFyYW1zO1xuXG4gIGlmIChzZXJpYWxpemVGbikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBzZXJpYWxpemVGbihwYXJhbXMsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSB1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpID9cbiAgICAgIHBhcmFtcy50b1N0cmluZygpIDpcbiAgICAgIG5ldyBBeGlvc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMsIG9wdGlvbnMpLnRvU3RyaW5nKF9lbmNvZGUpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICBjb25zdCBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoXCIjXCIpO1xuXG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5cbmNsYXNzIEludGVyY2VwdG9yTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICAgKi9cbiAgdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgICAgZnVsZmlsbGVkLFxuICAgICAgcmVqZWN0ZWQsXG4gICAgICBzeW5jaHJvbm91czogb3B0aW9ucyA/IG9wdGlvbnMuc3luY2hyb25vdXMgOiBmYWxzZSxcbiAgICAgIHJ1bldoZW46IG9wdGlvbnMgPyBvcHRpb25zLnJ1bldoZW4gOiBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGVqZWN0KGlkKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBpbnRlcmNlcHRvcnMgZnJvbSB0aGUgc3RhY2tcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBjbGVhcigpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVycykge1xuICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICAgKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmb3JFYWNoKGZuKSB7XG4gICAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgICBmbihoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNpbGVudEpTT05QYXJzaW5nOiB0cnVlLFxuICBmb3JjZWRKU09OUGFyc2luZzogdHJ1ZSxcbiAgY2xhcmlmeVRpbWVvdXRFcnJvcjogZmFsc2Vcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXhpb3NVUkxTZWFyY2hQYXJhbXMgZnJvbSAnLi4vLi4vLi4vaGVscGVycy9BeGlvc1VSTFNlYXJjaFBhcmFtcy5qcyc7XG5leHBvcnQgZGVmYXVsdCB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyA/IFVSTFNlYXJjaFBhcmFtcyA6IEF4aW9zVVJMU2VhcmNoUGFyYW1zO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQgdHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyA/IEZvcm1EYXRhIDogbnVsbDtcbiIsICIndXNlIHN0cmljdCdcblxuZXhwb3J0IGRlZmF1bHQgdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnID8gQmxvYiA6IG51bGxcbiIsICJpbXBvcnQgVVJMU2VhcmNoUGFyYW1zIGZyb20gJy4vY2xhc3Nlcy9VUkxTZWFyY2hQYXJhbXMuanMnXG5pbXBvcnQgRm9ybURhdGEgZnJvbSAnLi9jbGFzc2VzL0Zvcm1EYXRhLmpzJ1xuaW1wb3J0IEJsb2IgZnJvbSAnLi9jbGFzc2VzL0Jsb2IuanMnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNCcm93c2VyOiB0cnVlLFxuICBjbGFzc2VzOiB7XG4gICAgVVJMU2VhcmNoUGFyYW1zLFxuICAgIEZvcm1EYXRhLFxuICAgIEJsb2JcbiAgfSxcbiAgcHJvdG9jb2xzOiBbJ2h0dHAnLCAnaHR0cHMnLCAnZmlsZScsICdibG9iJywgJ3VybCcsICdkYXRhJ11cbn07XG4iLCAiY29uc3QgaGFzQnJvd3NlckVudiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmNvbnN0IF9uYXZpZ2F0b3IgPSB0eXBlb2YgbmF2aWdhdG9yID09PSAnb2JqZWN0JyAmJiBuYXZpZ2F0b3IgfHwgdW5kZWZpbmVkO1xuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqIG5hdGl2ZXNjcmlwdFxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdOYXRpdmVTY3JpcHQnIG9yICdOUydcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaGFzU3RhbmRhcmRCcm93c2VyRW52ID0gaGFzQnJvd3NlckVudiAmJlxuICAoIV9uYXZpZ2F0b3IgfHwgWydSZWFjdE5hdGl2ZScsICdOYXRpdmVTY3JpcHQnLCAnTlMnXS5pbmRleE9mKF9uYXZpZ2F0b3IucHJvZHVjdCkgPCAwKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgd2ViV29ya2VyIGVudmlyb25tZW50XG4gKlxuICogQWx0aG91Z2ggdGhlIGBpc1N0YW5kYXJkQnJvd3NlckVudmAgbWV0aG9kIGluZGljYXRlcyB0aGF0XG4gKiBgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXJgLCB0aGUgV2ViV29ya2VyIHdpbGwgc3RpbGwgYmVcbiAqIGZpbHRlcmVkIG91dCBkdWUgdG8gaXRzIGp1ZGdtZW50IHN0YW5kYXJkXG4gKiBgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ2AuXG4gKiBUaGlzIGxlYWRzIHRvIGEgcHJvYmxlbSB3aGVuIGF4aW9zIHBvc3QgYEZvcm1EYXRhYCBpbiB3ZWJXb3JrZXJcbiAqL1xuY29uc3QgaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52ID0gKCgpID0+IHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlICYmXG4gICAgdHlwZW9mIHNlbGYuaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJ1xuICApO1xufSkoKTtcblxuY29uc3Qgb3JpZ2luID0gaGFzQnJvd3NlckVudiAmJiB3aW5kb3cubG9jYXRpb24uaHJlZiB8fCAnaHR0cDovL2xvY2FsaG9zdCc7XG5cbmV4cG9ydCB7XG4gIGhhc0Jyb3dzZXJFbnYsXG4gIGhhc1N0YW5kYXJkQnJvd3NlcldlYldvcmtlckVudixcbiAgaGFzU3RhbmRhcmRCcm93c2VyRW52LFxuICBfbmF2aWdhdG9yIGFzIG5hdmlnYXRvcixcbiAgb3JpZ2luXG59XG4iLCAiaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4vbm9kZS9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL2NvbW1vbi91dGlscy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLi4udXRpbHMsXG4gIC4uLnBsYXRmb3JtXG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi90b0Zvcm1EYXRhLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvVVJMRW5jb2RlZEZvcm0oZGF0YSwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Gb3JtRGF0YShkYXRhLCBuZXcgcGxhdGZvcm0uY2xhc3Nlcy5VUkxTZWFyY2hQYXJhbXMoKSwge1xuICAgIHZpc2l0b3I6IGZ1bmN0aW9uKHZhbHVlLCBrZXksIHBhdGgsIGhlbHBlcnMpIHtcbiAgICAgIGlmIChwbGF0Zm9ybS5pc05vZGUgJiYgdXRpbHMuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGtleSwgdmFsdWUudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGVscGVycy5kZWZhdWx0VmlzaXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgLi4ub3B0aW9uc1xuICB9KTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5cbi8qKlxuICogSXQgdGFrZXMgYSBzdHJpbmcgbGlrZSBgZm9vW3hdW3ldW3pdYCBhbmQgcmV0dXJucyBhbiBhcnJheSBsaWtlIGBbJ2ZvbycsICd4JywgJ3knLCAneiddXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICpcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUHJvcFBhdGgobmFtZSkge1xuICAvLyBmb29beF1beV1bel1cbiAgLy8gZm9vLngueS56XG4gIC8vIGZvby14LXktelxuICAvLyBmb28geCB5IHpcbiAgcmV0dXJuIHV0aWxzLm1hdGNoQWxsKC9cXHcrfFxcWyhcXHcqKV0vZywgbmFtZSkubWFwKG1hdGNoID0+IHtcbiAgICByZXR1cm4gbWF0Y2hbMF0gPT09ICdbXScgPyAnJyA6IG1hdGNoWzFdIHx8IG1hdGNoWzBdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIGFycmF5IHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IGFyciAtIFRoZSBhcnJheSB0byBjb252ZXJ0IHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFuZCB2YWx1ZXMgYXMgdGhlIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheVRvT2JqZWN0KGFycikge1xuICBjb25zdCBvYmogPSB7fTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGFycik7XG4gIGxldCBpO1xuICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgbGV0IGtleTtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICBvYmpba2V5XSA9IGFycltrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSBGb3JtRGF0YSBvYmplY3QgYW5kIHJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtRGF0YSBUaGUgRm9ybURhdGEgb2JqZWN0IHRvIGNvbnZlcnQgdG8gSlNPTi5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0PHN0cmluZywgYW55PiB8IG51bGx9IFRoZSBjb252ZXJ0ZWQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBmb3JtRGF0YVRvSlNPTihmb3JtRGF0YSkge1xuICBmdW5jdGlvbiBidWlsZFBhdGgocGF0aCwgdmFsdWUsIHRhcmdldCwgaW5kZXgpIHtcbiAgICBsZXQgbmFtZSA9IHBhdGhbaW5kZXgrK107XG5cbiAgICBpZiAobmFtZSA9PT0gJ19fcHJvdG9fXycpIHJldHVybiB0cnVlO1xuXG4gICAgY29uc3QgaXNOdW1lcmljS2V5ID0gTnVtYmVyLmlzRmluaXRlKCtuYW1lKTtcbiAgICBjb25zdCBpc0xhc3QgPSBpbmRleCA+PSBwYXRoLmxlbmd0aDtcbiAgICBuYW1lID0gIW5hbWUgJiYgdXRpbHMuaXNBcnJheSh0YXJnZXQpID8gdGFyZ2V0Lmxlbmd0aCA6IG5hbWU7XG5cbiAgICBpZiAoaXNMYXN0KSB7XG4gICAgICBpZiAodXRpbHMuaGFzT3duUHJvcCh0YXJnZXQsIG5hbWUpKSB7XG4gICAgICAgIHRhcmdldFtuYW1lXSA9IFt0YXJnZXRbbmFtZV0sIHZhbHVlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gIWlzTnVtZXJpY0tleTtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldFtuYW1lXSB8fCAhdXRpbHMuaXNPYmplY3QodGFyZ2V0W25hbWVdKSkge1xuICAgICAgdGFyZ2V0W25hbWVdID0gW107XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYnVpbGRQYXRoKHBhdGgsIHZhbHVlLCB0YXJnZXRbbmFtZV0sIGluZGV4KTtcblxuICAgIGlmIChyZXN1bHQgJiYgdXRpbHMuaXNBcnJheSh0YXJnZXRbbmFtZV0pKSB7XG4gICAgICB0YXJnZXRbbmFtZV0gPSBhcnJheVRvT2JqZWN0KHRhcmdldFtuYW1lXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICFpc051bWVyaWNLZXk7XG4gIH1cblxuICBpZiAodXRpbHMuaXNGb3JtRGF0YShmb3JtRGF0YSkgJiYgdXRpbHMuaXNGdW5jdGlvbihmb3JtRGF0YS5lbnRyaWVzKSkge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuXG4gICAgdXRpbHMuZm9yRWFjaEVudHJ5KGZvcm1EYXRhLCAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgIGJ1aWxkUGF0aChwYXJzZVByb3BQYXRoKG5hbWUpLCB2YWx1ZSwgb2JqLCAwKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZm9ybURhdGFUb0pTT047XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbmltcG9ydCB0cmFuc2l0aW9uYWxEZWZhdWx0cyBmcm9tICcuL3RyYW5zaXRpb25hbC5qcyc7XG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuLi9oZWxwZXJzL3RvRm9ybURhdGEuanMnO1xuaW1wb3J0IHRvVVJMRW5jb2RlZEZvcm0gZnJvbSAnLi4vaGVscGVycy90b1VSTEVuY29kZWRGb3JtLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5pbXBvcnQgZm9ybURhdGFUb0pTT04gZnJvbSAnLi4vaGVscGVycy9mb3JtRGF0YVRvSlNPTi5qcyc7XG5cbi8qKlxuICogSXQgdGFrZXMgYSBzdHJpbmcsIHRyaWVzIHRvIHBhcnNlIGl0LCBhbmQgaWYgaXQgZmFpbHMsIGl0IHJldHVybnMgdGhlIHN0cmluZ2lmaWVkIHZlcnNpb25cbiAqIG9mIHRoZSBpbnB1dFxuICpcbiAqIEBwYXJhbSB7YW55fSByYXdWYWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSBzdHJpbmdpZmllZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBhcnNlciAtIEEgZnVuY3Rpb24gdGhhdCBwYXJzZXMgYSBzdHJpbmcgaW50byBhIEphdmFTY3JpcHQgb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlciAtIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHZhbHVlIGFuZCByZXR1cm5zIGEgc3RyaW5nLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5naWZpZWQgdmVyc2lvbiBvZiB0aGUgcmF3VmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeVNhZmVseShyYXdWYWx1ZSwgcGFyc2VyLCBlbmNvZGVyKSB7XG4gIGlmICh1dGlscy5pc1N0cmluZyhyYXdWYWx1ZSkpIHtcbiAgICB0cnkge1xuICAgICAgKHBhcnNlciB8fCBKU09OLnBhcnNlKShyYXdWYWx1ZSk7XG4gICAgICByZXR1cm4gdXRpbHMudHJpbShyYXdWYWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUubmFtZSAhPT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoZW5jb2RlciB8fCBKU09OLnN0cmluZ2lmeSkocmF3VmFsdWUpO1xufVxuXG5jb25zdCBkZWZhdWx0cyA9IHtcblxuICB0cmFuc2l0aW9uYWw6IHRyYW5zaXRpb25hbERlZmF1bHRzLFxuXG4gIGFkYXB0ZXI6IFsneGhyJywgJ2h0dHAnLCAnZmV0Y2gnXSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgY29uc3QgY29udGVudFR5cGUgPSBoZWFkZXJzLmdldENvbnRlbnRUeXBlKCkgfHwgJyc7XG4gICAgY29uc3QgaGFzSlNPTkNvbnRlbnRUeXBlID0gY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID4gLTE7XG4gICAgY29uc3QgaXNPYmplY3RQYXlsb2FkID0gdXRpbHMuaXNPYmplY3QoZGF0YSk7XG5cbiAgICBpZiAoaXNPYmplY3RQYXlsb2FkICYmIHV0aWxzLmlzSFRNTEZvcm0oZGF0YSkpIHtcbiAgICAgIGRhdGEgPSBuZXcgRm9ybURhdGEoZGF0YSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNGb3JtRGF0YSA9IHV0aWxzLmlzRm9ybURhdGEoZGF0YSk7XG5cbiAgICBpZiAoaXNGb3JtRGF0YSkge1xuICAgICAgcmV0dXJuIGhhc0pTT05Db250ZW50VHlwZSA/IEpTT04uc3RyaW5naWZ5KGZvcm1EYXRhVG9KU09OKGRhdGEpKSA6IGRhdGE7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzUmVhZGFibGVTdHJlYW0oZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcsIGZhbHNlKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgbGV0IGlzRmlsZUxpc3Q7XG5cbiAgICBpZiAoaXNPYmplY3RQYXlsb2FkKSB7XG4gICAgICBpZiAoY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJykgPiAtMSkge1xuICAgICAgICByZXR1cm4gdG9VUkxFbmNvZGVkRm9ybShkYXRhLCB0aGlzLmZvcm1TZXJpYWxpemVyKS50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGlzRmlsZUxpc3QgPSB1dGlscy5pc0ZpbGVMaXN0KGRhdGEpKSB8fCBjb250ZW50VHlwZS5pbmRleE9mKCdtdWx0aXBhcnQvZm9ybS1kYXRhJykgPiAtMSkge1xuICAgICAgICBjb25zdCBfRm9ybURhdGEgPSB0aGlzLmVudiAmJiB0aGlzLmVudi5Gb3JtRGF0YTtcblxuICAgICAgICByZXR1cm4gdG9Gb3JtRGF0YShcbiAgICAgICAgICBpc0ZpbGVMaXN0ID8geydmaWxlc1tdJzogZGF0YX0gOiBkYXRhLFxuICAgICAgICAgIF9Gb3JtRGF0YSAmJiBuZXcgX0Zvcm1EYXRhKCksXG4gICAgICAgICAgdGhpcy5mb3JtU2VyaWFsaXplclxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc09iamVjdFBheWxvYWQgfHwgaGFzSlNPTkNvbnRlbnRUeXBlICkge1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24vanNvbicsIGZhbHNlKTtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlTYWZlbHkoZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIGNvbnN0IHRyYW5zaXRpb25hbCA9IHRoaXMudHJhbnNpdGlvbmFsIHx8IGRlZmF1bHRzLnRyYW5zaXRpb25hbDtcbiAgICBjb25zdCBmb3JjZWRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuZm9yY2VkSlNPTlBhcnNpbmc7XG4gICAgY29uc3QgSlNPTlJlcXVlc3RlZCA9IHRoaXMucmVzcG9uc2VUeXBlID09PSAnanNvbic7XG5cbiAgICBpZiAodXRpbHMuaXNSZXNwb25zZShkYXRhKSB8fCB1dGlscy5pc1JlYWRhYmxlU3RyZWFtKGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YSAmJiB1dGlscy5pc1N0cmluZyhkYXRhKSAmJiAoKGZvcmNlZEpTT05QYXJzaW5nICYmICF0aGlzLnJlc3BvbnNlVHlwZSkgfHwgSlNPTlJlcXVlc3RlZCkpIHtcbiAgICAgIGNvbnN0IHNpbGVudEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5zaWxlbnRKU09OUGFyc2luZztcbiAgICAgIGNvbnN0IHN0cmljdEpTT05QYXJzaW5nID0gIXNpbGVudEpTT05QYXJzaW5nICYmIEpTT05SZXF1ZXN0ZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEsIHRoaXMucGFyc2VSZXZpdmVyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHN0cmljdEpTT05QYXJzaW5nKSB7XG4gICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgQXhpb3NFcnJvci5mcm9tKGUsIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVNQT05TRSwgdGhpcywgbnVsbCwgdGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxuXG4gIGVudjoge1xuICAgIEZvcm1EYXRhOiBwbGF0Zm9ybS5jbGFzc2VzLkZvcm1EYXRhLFxuICAgIEJsb2I6IHBsYXRmb3JtLmNsYXNzZXMuQmxvYlxuICB9LFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH0sXG5cbiAgaGVhZGVyczoge1xuICAgIGNvbW1vbjoge1xuICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCddLCAobWV0aG9kKSA9PiB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRzO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuXG4vLyBSYXdBeGlvc0hlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG5jb25zdCBpZ25vcmVEdXBsaWNhdGVPZiA9IHV0aWxzLnRvT2JqZWN0U2V0KFtcbiAgJ2FnZScsICdhdXRob3JpemF0aW9uJywgJ2NvbnRlbnQtbGVuZ3RoJywgJ2NvbnRlbnQtdHlwZScsICdldGFnJyxcbiAgJ2V4cGlyZXMnLCAnZnJvbScsICdob3N0JywgJ2lmLW1vZGlmaWVkLXNpbmNlJywgJ2lmLXVubW9kaWZpZWQtc2luY2UnLFxuICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICdyZWZlcmVyJywgJ3JldHJ5LWFmdGVyJywgJ3VzZXItYWdlbnQnXG5dKTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJhd0hlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHJhd0hlYWRlcnMgPT4ge1xuICBjb25zdCBwYXJzZWQgPSB7fTtcbiAgbGV0IGtleTtcbiAgbGV0IHZhbDtcbiAgbGV0IGk7XG5cbiAgcmF3SGVhZGVycyAmJiByYXdIZWFkZXJzLnNwbGl0KCdcXG4nKS5mb3JFYWNoKGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IGxpbmUuc3Vic3RyaW5nKDAsIGkpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IGxpbmUuc3Vic3RyaW5nKGkgKyAxKS50cmltKCk7XG5cbiAgICBpZiAoIWtleSB8fCAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2Zba2V5XSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSkge1xuICAgICAgICBwYXJzZWRba2V5XS5wdXNoKHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IFt2YWxdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHBhcnNlSGVhZGVycyBmcm9tICcuLi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyc7XG5cbmNvbnN0ICRpbnRlcm5hbHMgPSBTeW1ib2woJ2ludGVybmFscycpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVIZWFkZXIoaGVhZGVyKSB7XG4gIHJldHVybiBoZWFkZXIgJiYgU3RyaW5nKGhlYWRlcikudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB1dGlscy5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcChub3JtYWxpemVWYWx1ZSkgOiBTdHJpbmcodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRva2VucyhzdHIpIHtcbiAgY29uc3QgdG9rZW5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3QgdG9rZW5zUkUgPSAvKFteXFxzLDs9XSspXFxzKig/Oj1cXHMqKFteLDtdKykpPy9nO1xuICBsZXQgbWF0Y2g7XG5cbiAgd2hpbGUgKChtYXRjaCA9IHRva2Vuc1JFLmV4ZWMoc3RyKSkpIHtcbiAgICB0b2tlbnNbbWF0Y2hbMV1dID0gbWF0Y2hbMl07XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufVxuXG5jb25zdCBpc1ZhbGlkSGVhZGVyTmFtZSA9IChzdHIpID0+IC9eWy1fYS16QS1aMC05XmB8fiwhIyQlJicqKy5dKyQvLnRlc3Qoc3RyLnRyaW0oKSk7XG5cbmZ1bmN0aW9uIG1hdGNoSGVhZGVyVmFsdWUoY29udGV4dCwgdmFsdWUsIGhlYWRlciwgZmlsdGVyLCBpc0hlYWRlck5hbWVGaWx0ZXIpIHtcbiAgaWYgKHV0aWxzLmlzRnVuY3Rpb24oZmlsdGVyKSkge1xuICAgIHJldHVybiBmaWx0ZXIuY2FsbCh0aGlzLCB2YWx1ZSwgaGVhZGVyKTtcbiAgfVxuXG4gIGlmIChpc0hlYWRlck5hbWVGaWx0ZXIpIHtcbiAgICB2YWx1ZSA9IGhlYWRlcjtcbiAgfVxuXG4gIGlmICghdXRpbHMuaXNTdHJpbmcodmFsdWUpKSByZXR1cm47XG5cbiAgaWYgKHV0aWxzLmlzU3RyaW5nKGZpbHRlcikpIHtcbiAgICByZXR1cm4gdmFsdWUuaW5kZXhPZihmaWx0ZXIpICE9PSAtMTtcbiAgfVxuXG4gIGlmICh1dGlscy5pc1JlZ0V4cChmaWx0ZXIpKSB7XG4gICAgcmV0dXJuIGZpbHRlci50ZXN0KHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXRIZWFkZXIoaGVhZGVyKSB7XG4gIHJldHVybiBoZWFkZXIudHJpbSgpXG4gICAgLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvKFthLXpcXGRdKShcXHcqKS9nLCAodywgY2hhciwgc3RyKSA9PiB7XG4gICAgICByZXR1cm4gY2hhci50b1VwcGVyQ2FzZSgpICsgc3RyO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBidWlsZEFjY2Vzc29ycyhvYmosIGhlYWRlcikge1xuICBjb25zdCBhY2Nlc3Nvck5hbWUgPSB1dGlscy50b0NhbWVsQ2FzZSgnICcgKyBoZWFkZXIpO1xuXG4gIFsnZ2V0JywgJ3NldCcsICdoYXMnXS5mb3JFYWNoKG1ldGhvZE5hbWUgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG1ldGhvZE5hbWUgKyBhY2Nlc3Nvck5hbWUsIHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIHJldHVybiB0aGlzW21ldGhvZE5hbWVdLmNhbGwodGhpcywgaGVhZGVyLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfSk7XG59XG5cbmNsYXNzIEF4aW9zSGVhZGVycyB7XG4gIGNvbnN0cnVjdG9yKGhlYWRlcnMpIHtcbiAgICBoZWFkZXJzICYmIHRoaXMuc2V0KGhlYWRlcnMpO1xuICB9XG5cbiAgc2V0KGhlYWRlciwgdmFsdWVPclJld3JpdGUsIHJld3JpdGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIHNldEhlYWRlcihfdmFsdWUsIF9oZWFkZXIsIF9yZXdyaXRlKSB7XG4gICAgICBjb25zdCBsSGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKF9oZWFkZXIpO1xuXG4gICAgICBpZiAoIWxIZWFkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZWFkZXIgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KHNlbGYsIGxIZWFkZXIpO1xuXG4gICAgICBpZigha2V5IHx8IHNlbGZba2V5XSA9PT0gdW5kZWZpbmVkIHx8IF9yZXdyaXRlID09PSB0cnVlIHx8IChfcmV3cml0ZSA9PT0gdW5kZWZpbmVkICYmIHNlbGZba2V5XSAhPT0gZmFsc2UpKSB7XG4gICAgICAgIHNlbGZba2V5IHx8IF9oZWFkZXJdID0gbm9ybWFsaXplVmFsdWUoX3ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZXRIZWFkZXJzID0gKGhlYWRlcnMsIF9yZXdyaXRlKSA9PlxuICAgICAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCAoX3ZhbHVlLCBfaGVhZGVyKSA9PiBzZXRIZWFkZXIoX3ZhbHVlLCBfaGVhZGVyLCBfcmV3cml0ZSkpO1xuXG4gICAgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3QoaGVhZGVyKSB8fCBoZWFkZXIgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yKSB7XG4gICAgICBzZXRIZWFkZXJzKGhlYWRlciwgdmFsdWVPclJld3JpdGUpXG4gICAgfSBlbHNlIGlmKHV0aWxzLmlzU3RyaW5nKGhlYWRlcikgJiYgKGhlYWRlciA9IGhlYWRlci50cmltKCkpICYmICFpc1ZhbGlkSGVhZGVyTmFtZShoZWFkZXIpKSB7XG4gICAgICBzZXRIZWFkZXJzKHBhcnNlSGVhZGVycyhoZWFkZXIpLCB2YWx1ZU9yUmV3cml0ZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdChoZWFkZXIpICYmIHV0aWxzLmlzSXRlcmFibGUoaGVhZGVyKSkge1xuICAgICAgbGV0IG9iaiA9IHt9LCBkZXN0LCBrZXk7XG4gICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGhlYWRlcikge1xuICAgICAgICBpZiAoIXV0aWxzLmlzQXJyYXkoZW50cnkpKSB7XG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdPYmplY3QgaXRlcmF0b3IgbXVzdCByZXR1cm4gYSBrZXktdmFsdWUgcGFpcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqW2tleSA9IGVudHJ5WzBdXSA9IChkZXN0ID0gb2JqW2tleV0pID9cbiAgICAgICAgICAodXRpbHMuaXNBcnJheShkZXN0KSA/IFsuLi5kZXN0LCBlbnRyeVsxXV0gOiBbZGVzdCwgZW50cnlbMV1dKSA6IGVudHJ5WzFdO1xuICAgICAgfVxuXG4gICAgICBzZXRIZWFkZXJzKG9iaiwgdmFsdWVPclJld3JpdGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWRlciAhPSBudWxsICYmIHNldEhlYWRlcih2YWx1ZU9yUmV3cml0ZSwgaGVhZGVyLCByZXdyaXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldChoZWFkZXIsIHBhcnNlcikge1xuICAgIGhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihoZWFkZXIpO1xuXG4gICAgaWYgKGhlYWRlcikge1xuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleSh0aGlzLCBoZWFkZXIpO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1trZXldO1xuXG4gICAgICAgIGlmICghcGFyc2VyKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnNlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZVRva2Vucyh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihwYXJzZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlci5jYWxsKHRoaXMsIHZhbHVlLCBrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzUmVnRXhwKHBhcnNlcikpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLmV4ZWModmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyc2VyIG11c3QgYmUgYm9vbGVhbnxyZWdleHB8ZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYXMoaGVhZGVyLCBtYXRjaGVyKSB7XG4gICAgaGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKGhlYWRlcik7XG5cbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KHRoaXMsIGhlYWRlcik7XG5cbiAgICAgIHJldHVybiAhIShrZXkgJiYgdGhpc1trZXldICE9PSB1bmRlZmluZWQgJiYgKCFtYXRjaGVyIHx8IG1hdGNoSGVhZGVyVmFsdWUodGhpcywgdGhpc1trZXldLCBrZXksIG1hdGNoZXIpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZGVsZXRlKGhlYWRlciwgbWF0Y2hlcikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBkZWxldGVIZWFkZXIoX2hlYWRlcikge1xuICAgICAgX2hlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihfaGVhZGVyKTtcblxuICAgICAgaWYgKF9oZWFkZXIpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleShzZWxmLCBfaGVhZGVyKTtcblxuICAgICAgICBpZiAoa2V5ICYmICghbWF0Y2hlciB8fCBtYXRjaEhlYWRlclZhbHVlKHNlbGYsIHNlbGZba2V5XSwga2V5LCBtYXRjaGVyKSkpIHtcbiAgICAgICAgICBkZWxldGUgc2VsZltrZXldO1xuXG4gICAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNBcnJheShoZWFkZXIpKSB7XG4gICAgICBoZWFkZXIuZm9yRWFjaChkZWxldGVIZWFkZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGVIZWFkZXIoaGVhZGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVsZXRlZDtcbiAgfVxuXG4gIGNsZWFyKG1hdGNoZXIpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gICAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQgZGVsZXRlZCA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmKCFtYXRjaGVyIHx8IG1hdGNoSGVhZGVyVmFsdWUodGhpcywgdGhpc1trZXldLCBrZXksIG1hdGNoZXIsIHRydWUpKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzW2tleV07XG4gICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZWxldGVkO1xuICB9XG5cbiAgbm9ybWFsaXplKGZvcm1hdCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcblxuICAgIHV0aWxzLmZvckVhY2godGhpcywgKHZhbHVlLCBoZWFkZXIpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkoaGVhZGVycywgaGVhZGVyKTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBzZWxmW2tleV0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGRlbGV0ZSBzZWxmW2hlYWRlcl07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGZvcm1hdCA/IGZvcm1hdEhlYWRlcihoZWFkZXIpIDogU3RyaW5nKGhlYWRlcikudHJpbSgpO1xuXG4gICAgICBpZiAobm9ybWFsaXplZCAhPT0gaGVhZGVyKSB7XG4gICAgICAgIGRlbGV0ZSBzZWxmW2hlYWRlcl07XG4gICAgICB9XG5cbiAgICAgIHNlbGZbbm9ybWFsaXplZF0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG5cbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZF0gPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb25jYXQoLi4udGFyZ2V0cykge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmNvbmNhdCh0aGlzLCAuLi50YXJnZXRzKTtcbiAgfVxuXG4gIHRvSlNPTihhc1N0cmluZ3MpIHtcbiAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgdXRpbHMuZm9yRWFjaCh0aGlzLCAodmFsdWUsIGhlYWRlcikgPT4ge1xuICAgICAgdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2UgJiYgKG9ialtoZWFkZXJdID0gYXNTdHJpbmdzICYmIHV0aWxzLmlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbignLCAnKSA6IHZhbHVlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy50b0pTT04oKSlbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMudG9KU09OKCkpLm1hcCgoW2hlYWRlciwgdmFsdWVdKSA9PiBoZWFkZXIgKyAnOiAnICsgdmFsdWUpLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgZ2V0U2V0Q29va2llKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInNldC1jb29raWVcIikgfHwgW107XG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuICdBeGlvc0hlYWRlcnMnO1xuICB9XG5cbiAgc3RhdGljIGZyb20odGhpbmcpIHtcbiAgICByZXR1cm4gdGhpbmcgaW5zdGFuY2VvZiB0aGlzID8gdGhpbmcgOiBuZXcgdGhpcyh0aGluZyk7XG4gIH1cblxuICBzdGF0aWMgY29uY2F0KGZpcnN0LCAuLi50YXJnZXRzKSB7XG4gICAgY29uc3QgY29tcHV0ZWQgPSBuZXcgdGhpcyhmaXJzdCk7XG5cbiAgICB0YXJnZXRzLmZvckVhY2goKHRhcmdldCkgPT4gY29tcHV0ZWQuc2V0KHRhcmdldCkpO1xuXG4gICAgcmV0dXJuIGNvbXB1dGVkO1xuICB9XG5cbiAgc3RhdGljIGFjY2Vzc29yKGhlYWRlcikge1xuICAgIGNvbnN0IGludGVybmFscyA9IHRoaXNbJGludGVybmFsc10gPSAodGhpc1skaW50ZXJuYWxzXSA9IHtcbiAgICAgIGFjY2Vzc29yczoge31cbiAgICB9KTtcblxuICAgIGNvbnN0IGFjY2Vzc29ycyA9IGludGVybmFscy5hY2Nlc3NvcnM7XG4gICAgY29uc3QgcHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVBY2Nlc3NvcihfaGVhZGVyKSB7XG4gICAgICBjb25zdCBsSGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKF9oZWFkZXIpO1xuXG4gICAgICBpZiAoIWFjY2Vzc29yc1tsSGVhZGVyXSkge1xuICAgICAgICBidWlsZEFjY2Vzc29ycyhwcm90b3R5cGUsIF9oZWFkZXIpO1xuICAgICAgICBhY2Nlc3NvcnNbbEhlYWRlcl0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzLmlzQXJyYXkoaGVhZGVyKSA/IGhlYWRlci5mb3JFYWNoKGRlZmluZUFjY2Vzc29yKSA6IGRlZmluZUFjY2Vzc29yKGhlYWRlcik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5BeGlvc0hlYWRlcnMuYWNjZXNzb3IoWydDb250ZW50LVR5cGUnLCAnQ29udGVudC1MZW5ndGgnLCAnQWNjZXB0JywgJ0FjY2VwdC1FbmNvZGluZycsICdVc2VyLUFnZW50JywgJ0F1dGhvcml6YXRpb24nXSk7XG5cbi8vIHJlc2VydmVkIG5hbWVzIGhvdGZpeFxudXRpbHMucmVkdWNlRGVzY3JpcHRvcnMoQXhpb3NIZWFkZXJzLnByb3RvdHlwZSwgKHt2YWx1ZX0sIGtleSkgPT4ge1xuICBsZXQgbWFwcGVkID0ga2V5WzBdLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSk7IC8vIG1hcCBgc2V0YCA9PiBgU2V0YFxuICByZXR1cm4ge1xuICAgIGdldDogKCkgPT4gdmFsdWUsXG4gICAgc2V0KGhlYWRlclZhbHVlKSB7XG4gICAgICB0aGlzW21hcHBlZF0gPSBoZWFkZXJWYWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG51dGlscy5mcmVlemVNZXRob2RzKEF4aW9zSGVhZGVycyk7XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zSGVhZGVycztcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9kZWZhdWx0cy9pbmRleC5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzJztcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHBhcmFtIHs/T2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2Ugb2JqZWN0XG4gKlxuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGZucywgcmVzcG9uc2UpIHtcbiAgY29uc3QgY29uZmlnID0gdGhpcyB8fCBkZWZhdWx0cztcbiAgY29uc3QgY29udGV4dCA9IHJlc3BvbnNlIHx8IGNvbmZpZztcbiAgY29uc3QgaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKGNvbnRleHQuaGVhZGVycyk7XG4gIGxldCBkYXRhID0gY29udGV4dC5kYXRhO1xuXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4uY2FsbChjb25maWcsIGRhdGEsIGhlYWRlcnMubm9ybWFsaXplKCksIHJlc3BvbnNlID8gcmVzcG9uc2Uuc3RhdHVzIDogdW5kZWZpbmVkKTtcbiAgfSk7XG5cbiAgaGVhZGVycy5ub3JtYWxpemUoKTtcblxuICByZXR1cm4gZGF0YTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEEgYENhbmNlbGVkRXJyb3JgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtPYmplY3Q9fSByZXF1ZXN0IFRoZSByZXF1ZXN0LlxuICpcbiAqIEByZXR1cm5zIHtDYW5jZWxlZEVycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsZWRFcnJvcihtZXNzYWdlLCBjb25maWcsIHJlcXVlc3QpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gIEF4aW9zRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlID09IG51bGwgPyAnY2FuY2VsZWQnIDogbWVzc2FnZSwgQXhpb3NFcnJvci5FUlJfQ0FOQ0VMRUQsIGNvbmZpZywgcmVxdWVzdCk7XG4gIHRoaXMubmFtZSA9ICdDYW5jZWxlZEVycm9yJztcbn1cblxudXRpbHMuaW5oZXJpdHMoQ2FuY2VsZWRFcnJvciwgQXhpb3NFcnJvciwge1xuICBfX0NBTkNFTF9fOiB0cnVlXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQ2FuY2VsZWRFcnJvcjtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4vQXhpb3NFcnJvci5qcyc7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKlxuICogQHJldHVybnMge29iamVjdH0gVGhlIHJlc3BvbnNlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICBjb25zdCB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgW0F4aW9zRXJyb3IuRVJSX0JBRF9SRVFVRVNULCBBeGlvc0Vycm9yLkVSUl9CQURfUkVTUE9OU0VdW01hdGguZmxvb3IocmVzcG9uc2Uuc3RhdHVzIC8gMTAwKSAtIDRdLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBhcnNlUHJvdG9jb2wodXJsKSB7XG4gIGNvbnN0IG1hdGNoID0gL14oWy0rXFx3XXsxLDI1fSkoOj9cXC9cXC98OikvLmV4ZWModXJsKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDYWxjdWxhdGUgZGF0YSBtYXhSYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gW3NhbXBsZXNDb3VudD0gMTBdXG4gKiBAcGFyYW0ge051bWJlcn0gW21pbj0gMTAwMF1cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gc3BlZWRvbWV0ZXIoc2FtcGxlc0NvdW50LCBtaW4pIHtcbiAgc2FtcGxlc0NvdW50ID0gc2FtcGxlc0NvdW50IHx8IDEwO1xuICBjb25zdCBieXRlcyA9IG5ldyBBcnJheShzYW1wbGVzQ291bnQpO1xuICBjb25zdCB0aW1lc3RhbXBzID0gbmV3IEFycmF5KHNhbXBsZXNDb3VudCk7XG4gIGxldCBoZWFkID0gMDtcbiAgbGV0IHRhaWwgPSAwO1xuICBsZXQgZmlyc3RTYW1wbGVUUztcblxuICBtaW4gPSBtaW4gIT09IHVuZGVmaW5lZCA/IG1pbiA6IDEwMDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHB1c2goY2h1bmtMZW5ndGgpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgY29uc3Qgc3RhcnRlZEF0ID0gdGltZXN0YW1wc1t0YWlsXTtcblxuICAgIGlmICghZmlyc3RTYW1wbGVUUykge1xuICAgICAgZmlyc3RTYW1wbGVUUyA9IG5vdztcbiAgICB9XG5cbiAgICBieXRlc1toZWFkXSA9IGNodW5rTGVuZ3RoO1xuICAgIHRpbWVzdGFtcHNbaGVhZF0gPSBub3c7XG5cbiAgICBsZXQgaSA9IHRhaWw7XG4gICAgbGV0IGJ5dGVzQ291bnQgPSAwO1xuXG4gICAgd2hpbGUgKGkgIT09IGhlYWQpIHtcbiAgICAgIGJ5dGVzQ291bnQgKz0gYnl0ZXNbaSsrXTtcbiAgICAgIGkgPSBpICUgc2FtcGxlc0NvdW50O1xuICAgIH1cblxuICAgIGhlYWQgPSAoaGVhZCArIDEpICUgc2FtcGxlc0NvdW50O1xuXG4gICAgaWYgKGhlYWQgPT09IHRhaWwpIHtcbiAgICAgIHRhaWwgPSAodGFpbCArIDEpICUgc2FtcGxlc0NvdW50O1xuICAgIH1cblxuICAgIGlmIChub3cgLSBmaXJzdFNhbXBsZVRTIDwgbWluKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGFzc2VkID0gc3RhcnRlZEF0ICYmIG5vdyAtIHN0YXJ0ZWRBdDtcblxuICAgIHJldHVybiBwYXNzZWQgPyBNYXRoLnJvdW5kKGJ5dGVzQ291bnQgKiAxMDAwIC8gcGFzc2VkKSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3BlZWRvbWV0ZXI7XG4iLCAiLyoqXG4gKiBUaHJvdHRsZSBkZWNvcmF0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge051bWJlcn0gZnJlcVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZuLCBmcmVxKSB7XG4gIGxldCB0aW1lc3RhbXAgPSAwO1xuICBsZXQgdGhyZXNob2xkID0gMTAwMCAvIGZyZXE7XG4gIGxldCBsYXN0QXJncztcbiAgbGV0IHRpbWVyO1xuXG4gIGNvbnN0IGludm9rZSA9IChhcmdzLCBub3cgPSBEYXRlLm5vdygpKSA9PiB7XG4gICAgdGltZXN0YW1wID0gbm93O1xuICAgIGxhc3RBcmdzID0gbnVsbDtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgfVxuICAgIGZuKC4uLmFyZ3MpO1xuICB9XG5cbiAgY29uc3QgdGhyb3R0bGVkID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHBhc3NlZCA9IG5vdyAtIHRpbWVzdGFtcDtcbiAgICBpZiAoIHBhc3NlZCA+PSB0aHJlc2hvbGQpIHtcbiAgICAgIGludm9rZShhcmdzLCBub3cpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0QXJncyA9IGFyZ3M7XG4gICAgICBpZiAoIXRpbWVyKSB7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgIGludm9rZShsYXN0QXJncylcbiAgICAgICAgfSwgdGhyZXNob2xkIC0gcGFzc2VkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBmbHVzaCA9ICgpID0+IGxhc3RBcmdzICYmIGludm9rZShsYXN0QXJncyk7XG5cbiAgcmV0dXJuIFt0aHJvdHRsZWQsIGZsdXNoXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdGhyb3R0bGU7XG4iLCAiaW1wb3J0IHNwZWVkb21ldGVyIGZyb20gXCIuL3NwZWVkb21ldGVyLmpzXCI7XG5pbXBvcnQgdGhyb3R0bGUgZnJvbSBcIi4vdGhyb3R0bGUuanNcIjtcbmltcG9ydCB1dGlscyBmcm9tIFwiLi4vdXRpbHMuanNcIjtcblxuZXhwb3J0IGNvbnN0IHByb2dyZXNzRXZlbnRSZWR1Y2VyID0gKGxpc3RlbmVyLCBpc0Rvd25sb2FkU3RyZWFtLCBmcmVxID0gMykgPT4ge1xuICBsZXQgYnl0ZXNOb3RpZmllZCA9IDA7XG4gIGNvbnN0IF9zcGVlZG9tZXRlciA9IHNwZWVkb21ldGVyKDUwLCAyNTApO1xuXG4gIHJldHVybiB0aHJvdHRsZShlID0+IHtcbiAgICBjb25zdCBsb2FkZWQgPSBlLmxvYWRlZDtcbiAgICBjb25zdCB0b3RhbCA9IGUubGVuZ3RoQ29tcHV0YWJsZSA/IGUudG90YWwgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgcHJvZ3Jlc3NCeXRlcyA9IGxvYWRlZCAtIGJ5dGVzTm90aWZpZWQ7XG4gICAgY29uc3QgcmF0ZSA9IF9zcGVlZG9tZXRlcihwcm9ncmVzc0J5dGVzKTtcbiAgICBjb25zdCBpblJhbmdlID0gbG9hZGVkIDw9IHRvdGFsO1xuXG4gICAgYnl0ZXNOb3RpZmllZCA9IGxvYWRlZDtcblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBsb2FkZWQsXG4gICAgICB0b3RhbCxcbiAgICAgIHByb2dyZXNzOiB0b3RhbCA/IChsb2FkZWQgLyB0b3RhbCkgOiB1bmRlZmluZWQsXG4gICAgICBieXRlczogcHJvZ3Jlc3NCeXRlcyxcbiAgICAgIHJhdGU6IHJhdGUgPyByYXRlIDogdW5kZWZpbmVkLFxuICAgICAgZXN0aW1hdGVkOiByYXRlICYmIHRvdGFsICYmIGluUmFuZ2UgPyAodG90YWwgLSBsb2FkZWQpIC8gcmF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgIGV2ZW50OiBlLFxuICAgICAgbGVuZ3RoQ29tcHV0YWJsZTogdG90YWwgIT0gbnVsbCxcbiAgICAgIFtpc0Rvd25sb2FkU3RyZWFtID8gJ2Rvd25sb2FkJyA6ICd1cGxvYWQnXTogdHJ1ZVxuICAgIH07XG5cbiAgICBsaXN0ZW5lcihkYXRhKTtcbiAgfSwgZnJlcSk7XG59XG5cbmV4cG9ydCBjb25zdCBwcm9ncmVzc0V2ZW50RGVjb3JhdG9yID0gKHRvdGFsLCB0aHJvdHRsZWQpID0+IHtcbiAgY29uc3QgbGVuZ3RoQ29tcHV0YWJsZSA9IHRvdGFsICE9IG51bGw7XG5cbiAgcmV0dXJuIFsobG9hZGVkKSA9PiB0aHJvdHRsZWRbMF0oe1xuICAgIGxlbmd0aENvbXB1dGFibGUsXG4gICAgdG90YWwsXG4gICAgbG9hZGVkXG4gIH0pLCB0aHJvdHRsZWRbMV1dO1xufVxuXG5leHBvcnQgY29uc3QgYXN5bmNEZWNvcmF0b3IgPSAoZm4pID0+ICguLi5hcmdzKSA9PiB1dGlscy5hc2FwKCgpID0+IGZuKC4uLmFyZ3MpKTtcbiIsICJpbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgPyAoKG9yaWdpbiwgaXNNU0lFKSA9PiAodXJsKSA9PiB7XG4gIHVybCA9IG5ldyBVUkwodXJsLCBwbGF0Zm9ybS5vcmlnaW4pO1xuXG4gIHJldHVybiAoXG4gICAgb3JpZ2luLnByb3RvY29sID09PSB1cmwucHJvdG9jb2wgJiZcbiAgICBvcmlnaW4uaG9zdCA9PT0gdXJsLmhvc3QgJiZcbiAgICAoaXNNU0lFIHx8IG9yaWdpbi5wb3J0ID09PSB1cmwucG9ydClcbiAgKTtcbn0pKFxuICBuZXcgVVJMKHBsYXRmb3JtLm9yaWdpbiksXG4gIHBsYXRmb3JtLm5hdmlnYXRvciAmJiAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KHBsYXRmb3JtLm5hdmlnYXRvci51c2VyQWdlbnQpXG4pIDogKCkgPT4gdHJ1ZTtcbiIsICJpbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICB7XG4gICAgd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlLCBzYW1lU2l0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcblxuICAgICAgY29uc3QgY29va2llID0gW2Ake25hbWV9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKX1gXTtcblxuICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgIGNvb2tpZS5wdXNoKGBleHBpcmVzPSR7bmV3IERhdGUoZXhwaXJlcykudG9VVENTdHJpbmcoKX1gKTtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICBjb29raWUucHVzaChgcGF0aD0ke3BhdGh9YCk7XG4gICAgICB9XG4gICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICBjb29raWUucHVzaChgZG9tYWluPSR7ZG9tYWlufWApO1xuICAgICAgfVxuICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG4gICAgICB9XG4gICAgICBpZiAodXRpbHMuaXNTdHJpbmcoc2FtZVNpdGUpKSB7XG4gICAgICAgIGNvb2tpZS5wdXNoKGBTYW1lU2l0ZT0ke3NhbWVTaXRlfWApO1xuICAgICAgfVxuXG4gICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICB9LFxuXG4gICAgcmVhZChuYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoPzpefDsgKScgKyBuYW1lICsgJz0oW147XSopJykpO1xuICAgICAgcmV0dXJuIG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzFdKSA6IG51bGw7XG4gICAgfSxcblxuICAgIHJlbW92ZShuYW1lKSB7XG4gICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDAsICcvJyk7XG4gICAgfVxuICB9XG5cbiAgOlxuXG4gIC8vIE5vbi1zdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAge1xuICAgIHdyaXRlKCkge30sXG4gICAgcmVhZCgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgcmVtb3ZlKCkge31cbiAgfTtcblxuIiwgIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGQrXFwtLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLz9cXC8kLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgaXNBYnNvbHV0ZVVSTCBmcm9tICcuLi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMnO1xuaW1wb3J0IGNvbWJpbmVVUkxzIGZyb20gJy4uL2hlbHBlcnMvY29tYmluZVVSTHMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgYmFzZVVSTCB3aXRoIHRoZSByZXF1ZXN0ZWRVUkwsXG4gKiBvbmx5IHdoZW4gdGhlIHJlcXVlc3RlZFVSTCBpcyBub3QgYWxyZWFkeSBhbiBhYnNvbHV0ZSBVUkwuXG4gKiBJZiB0aGUgcmVxdWVzdFVSTCBpcyBhYnNvbHV0ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSByZXF1ZXN0ZWRVUkwgdW50b3VjaGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RlZFVSTCBBYnNvbHV0ZSBvciByZWxhdGl2ZSBVUkwgdG8gY29tYmluZVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBmdWxsIHBhdGhcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwsIGFsbG93QWJzb2x1dGVVcmxzKSB7XG4gIGxldCBpc1JlbGF0aXZlVXJsID0gIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKTtcbiAgaWYgKGJhc2VVUkwgJiYgKGlzUmVsYXRpdmVVcmwgfHwgYWxsb3dBYnNvbHV0ZVVybHMgPT0gZmFsc2UpKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCk7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3RlZFVSTDtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gXCIuL0F4aW9zSGVhZGVycy5qc1wiO1xuXG5jb25zdCBoZWFkZXJzVG9PYmplY3QgPSAodGhpbmcpID0+IHRoaW5nIGluc3RhbmNlb2YgQXhpb3NIZWFkZXJzID8geyAuLi50aGluZyB9IDogdGhpbmc7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBvYmplY3QgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyBjb25maWcyIHRvIGNvbmZpZzFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnMSwgY29uZmlnMikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgY29uZmlnMiA9IGNvbmZpZzIgfHwge307XG4gIGNvbnN0IGNvbmZpZyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGdldE1lcmdlZFZhbHVlKHRhcmdldCwgc291cmNlLCBwcm9wLCBjYXNlbGVzcykge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UuY2FsbCh7Y2FzZWxlc3N9LCB0YXJnZXQsIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh7fSwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMoYSwgYiwgcHJvcCwgY2FzZWxlc3MpIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGIpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUoYSwgYiwgcHJvcCwgY2FzZWxlc3MpO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGEpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBhLCBwcm9wLCBjYXNlbGVzcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIoYSwgYikge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYikpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBkZWZhdWx0VG9Db25maWcyKGEsIGIpIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGIpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBiKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChhKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIG1lcmdlRGlyZWN0S2V5cyhhLCBiLCBwcm9wKSB7XG4gICAgaWYgKHByb3AgaW4gY29uZmlnMikge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGEsIGIpO1xuICAgIH0gZWxzZSBpZiAocHJvcCBpbiBjb25maWcxKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBhKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBtZXJnZU1hcCA9IHtcbiAgICB1cmw6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgbWV0aG9kOiB2YWx1ZUZyb21Db25maWcyLFxuICAgIGRhdGE6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgYmFzZVVSTDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc2Zvcm1SZXF1ZXN0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRyYW5zZm9ybVJlc3BvbnNlOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHBhcmFtc1NlcmlhbGl6ZXI6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdGltZW91dDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0aW1lb3V0TWVzc2FnZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB3aXRoQ3JlZGVudGlhbHM6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgd2l0aFhTUkZUb2tlbjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBhZGFwdGVyOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHJlc3BvbnNlVHlwZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB4c3JmQ29va2llTmFtZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB4c3JmSGVhZGVyTmFtZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBvblVwbG9hZFByb2dyZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG9uRG93bmxvYWRQcm9ncmVzczogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBkZWNvbXByZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG1heENvbnRlbnRMZW5ndGg6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgbWF4Qm9keUxlbmd0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBiZWZvcmVSZWRpcmVjdDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc3BvcnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgaHR0cEFnZW50OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGh0dHBzQWdlbnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgY2FuY2VsVG9rZW46IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgc29ja2V0UGF0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICByZXNwb25zZUVuY29kaW5nOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHZhbGlkYXRlU3RhdHVzOiBtZXJnZURpcmVjdEtleXMsXG4gICAgaGVhZGVyczogKGEsIGIsIHByb3ApID0+IG1lcmdlRGVlcFByb3BlcnRpZXMoaGVhZGVyc1RvT2JqZWN0KGEpLCBoZWFkZXJzVG9PYmplY3QoYiksIHByb3AsIHRydWUpXG4gIH07XG5cbiAgdXRpbHMuZm9yRWFjaChPYmplY3Qua2V5cyh7Li4uY29uZmlnMSwgLi4uY29uZmlnMn0pLCBmdW5jdGlvbiBjb21wdXRlQ29uZmlnVmFsdWUocHJvcCkge1xuICAgIGNvbnN0IG1lcmdlID0gbWVyZ2VNYXBbcHJvcF0gfHwgbWVyZ2VEZWVwUHJvcGVydGllcztcbiAgICBjb25zdCBjb25maWdWYWx1ZSA9IG1lcmdlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0sIHByb3ApO1xuICAgICh1dGlscy5pc1VuZGVmaW5lZChjb25maWdWYWx1ZSkgJiYgbWVyZ2UgIT09IG1lcmdlRGlyZWN0S2V5cykgfHwgKGNvbmZpZ1twcm9wXSA9IGNvbmZpZ1ZhbHVlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn1cbiIsICJpbXBvcnQgcGxhdGZvcm0gZnJvbSBcIi4uL3BsYXRmb3JtL2luZGV4LmpzXCI7XG5pbXBvcnQgdXRpbHMgZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgaXNVUkxTYW1lT3JpZ2luIGZyb20gXCIuL2lzVVJMU2FtZU9yaWdpbi5qc1wiO1xuaW1wb3J0IGNvb2tpZXMgZnJvbSBcIi4vY29va2llcy5qc1wiO1xuaW1wb3J0IGJ1aWxkRnVsbFBhdGggZnJvbSBcIi4uL2NvcmUvYnVpbGRGdWxsUGF0aC5qc1wiO1xuaW1wb3J0IG1lcmdlQ29uZmlnIGZyb20gXCIuLi9jb3JlL21lcmdlQ29uZmlnLmpzXCI7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gXCIuLi9jb3JlL0F4aW9zSGVhZGVycy5qc1wiO1xuaW1wb3J0IGJ1aWxkVVJMIGZyb20gXCIuL2J1aWxkVVJMLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IChjb25maWcpID0+IHtcbiAgY29uc3QgbmV3Q29uZmlnID0gbWVyZ2VDb25maWcoe30sIGNvbmZpZyk7XG5cbiAgbGV0IHsgZGF0YSwgd2l0aFhTUkZUb2tlbiwgeHNyZkhlYWRlck5hbWUsIHhzcmZDb29raWVOYW1lLCBoZWFkZXJzLCBhdXRoIH0gPSBuZXdDb25maWc7XG5cbiAgbmV3Q29uZmlnLmhlYWRlcnMgPSBoZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oaGVhZGVycyk7XG5cbiAgbmV3Q29uZmlnLnVybCA9IGJ1aWxkVVJMKGJ1aWxkRnVsbFBhdGgobmV3Q29uZmlnLmJhc2VVUkwsIG5ld0NvbmZpZy51cmwsIG5ld0NvbmZpZy5hbGxvd0Fic29sdXRlVXJscyksIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKTtcblxuICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gIGlmIChhdXRoKSB7XG4gICAgaGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArXG4gICAgICBidG9hKChhdXRoLnVzZXJuYW1lIHx8ICcnKSArICc6JyArIChhdXRoLnBhc3N3b3JkID8gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgucGFzc3dvcmQpKSA6ICcnKSlcbiAgICApO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkpIHtcbiAgICBpZiAocGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyRW52IHx8IHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlcldlYldvcmtlckVudikge1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZSh1bmRlZmluZWQpOyAvLyBicm93c2VyIGhhbmRsZXMgaXRcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzRnVuY3Rpb24oZGF0YS5nZXRIZWFkZXJzKSkge1xuICAgICAgLy8gTm9kZS5qcyBGb3JtRGF0YSAobGlrZSBmb3JtLWRhdGEgcGFja2FnZSlcbiAgICAgIGNvbnN0IGZvcm1IZWFkZXJzID0gZGF0YS5nZXRIZWFkZXJzKCk7XG4gICAgICAvLyBPbmx5IHNldCBzYWZlIGhlYWRlcnMgdG8gYXZvaWQgb3ZlcndyaXRpbmcgc2VjdXJpdHkgaGVhZGVyc1xuICAgICAgY29uc3QgYWxsb3dlZEhlYWRlcnMgPSBbJ2NvbnRlbnQtdHlwZScsICdjb250ZW50LWxlbmd0aCddO1xuICAgICAgT2JqZWN0LmVudHJpZXMoZm9ybUhlYWRlcnMpLmZvckVhY2goKFtrZXksIHZhbF0pID0+IHtcbiAgICAgICAgaWYgKGFsbG93ZWRIZWFkZXJzLmluY2x1ZGVzKGtleS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9ICBcblxuICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG5cbiAgaWYgKHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlckVudikge1xuICAgIHdpdGhYU1JGVG9rZW4gJiYgdXRpbHMuaXNGdW5jdGlvbih3aXRoWFNSRlRva2VuKSAmJiAod2l0aFhTUkZUb2tlbiA9IHdpdGhYU1JGVG9rZW4obmV3Q29uZmlnKSk7XG5cbiAgICBpZiAod2l0aFhTUkZUb2tlbiB8fCAod2l0aFhTUkZUb2tlbiAhPT0gZmFsc2UgJiYgaXNVUkxTYW1lT3JpZ2luKG5ld0NvbmZpZy51cmwpKSkge1xuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICBjb25zdCB4c3JmVmFsdWUgPSB4c3JmSGVhZGVyTmFtZSAmJiB4c3JmQ29va2llTmFtZSAmJiBjb29raWVzLnJlYWQoeHNyZkNvb2tpZU5hbWUpO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KHhzcmZIZWFkZXJOYW1lLCB4c3JmVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdDb25maWc7XG59XG5cbiIsICJpbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgc2V0dGxlIGZyb20gJy4vLi4vY29yZS9zZXR0bGUuanMnO1xuaW1wb3J0IHRyYW5zaXRpb25hbERlZmF1bHRzIGZyb20gJy4uL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMnO1xuaW1wb3J0IHBhcnNlUHJvdG9jb2wgZnJvbSAnLi4vaGVscGVycy9wYXJzZVByb3RvY29sLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzJztcbmltcG9ydCB7cHJvZ3Jlc3NFdmVudFJlZHVjZXJ9IGZyb20gJy4uL2hlbHBlcnMvcHJvZ3Jlc3NFdmVudFJlZHVjZXIuanMnO1xuaW1wb3J0IHJlc29sdmVDb25maWcgZnJvbSBcIi4uL2hlbHBlcnMvcmVzb2x2ZUNvbmZpZy5qc1wiO1xuXG5jb25zdCBpc1hIUkFkYXB0ZXJTdXBwb3J0ZWQgPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnO1xuXG5leHBvcnQgZGVmYXVsdCBpc1hIUkFkYXB0ZXJTdXBwb3J0ZWQgJiYgZnVuY3Rpb24gKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIGNvbnN0IF9jb25maWcgPSByZXNvbHZlQ29uZmlnKGNvbmZpZyk7XG4gICAgbGV0IHJlcXVlc3REYXRhID0gX2NvbmZpZy5kYXRhO1xuICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oX2NvbmZpZy5oZWFkZXJzKS5ub3JtYWxpemUoKTtcbiAgICBsZXQge3Jlc3BvbnNlVHlwZSwgb25VcGxvYWRQcm9ncmVzcywgb25Eb3dubG9hZFByb2dyZXNzfSA9IF9jb25maWc7XG4gICAgbGV0IG9uQ2FuY2VsZWQ7XG4gICAgbGV0IHVwbG9hZFRocm90dGxlZCwgZG93bmxvYWRUaHJvdHRsZWQ7XG4gICAgbGV0IGZsdXNoVXBsb2FkLCBmbHVzaERvd25sb2FkO1xuXG4gICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgIGZsdXNoVXBsb2FkICYmIGZsdXNoVXBsb2FkKCk7IC8vIGZsdXNoIGV2ZW50c1xuICAgICAgZmx1c2hEb3dubG9hZCAmJiBmbHVzaERvd25sb2FkKCk7IC8vIGZsdXNoIGV2ZW50c1xuXG4gICAgICBfY29uZmlnLmNhbmNlbFRva2VuICYmIF9jb25maWcuY2FuY2VsVG9rZW4udW5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG5cbiAgICAgIF9jb25maWcuc2lnbmFsICYmIF9jb25maWcuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25DYW5jZWxlZCk7XG4gICAgfVxuXG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIHJlcXVlc3Qub3BlbihfY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBfY29uZmlnLnVybCwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IF9jb25maWcudGltZW91dDtcblxuICAgIGZ1bmN0aW9uIG9ubG9hZGVuZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oXG4gICAgICAgICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgJiYgcmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9ICFyZXNwb25zZVR5cGUgfHwgcmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgcmVzcG9uc2VUeXBlID09PSAnanNvbicgP1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUoZnVuY3Rpb24gX3Jlc29sdmUodmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIGZ1bmN0aW9uIF9yZWplY3QoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICgnb25sb2FkZW5kJyBpbiByZXF1ZXN0KSB7XG4gICAgICAvLyBVc2Ugb25sb2FkZW5kIGlmIGF2YWlsYWJsZVxuICAgICAgcmVxdWVzdC5vbmxvYWRlbmQgPSBvbmxvYWRlbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGUgdG8gZW11bGF0ZSBvbmxvYWRlbmRcbiAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWFkeXN0YXRlIGhhbmRsZXIgaXMgY2FsbGluZyBiZWZvcmUgb25lcnJvciBvciBvbnRpbWVvdXQgaGFuZGxlcnMsXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBjYWxsIG9ubG9hZGVuZCBvbiB0aGUgbmV4dCAndGljaydcbiAgICAgICAgc2V0VGltZW91dChvbmxvYWRlbmQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgYnJvd3NlciByZXF1ZXN0IGNhbmNlbGxhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIG1hbnVhbCBjYW5jZWxsYXRpb24pXG4gICAgcmVxdWVzdC5vbmFib3J0ID0gZnVuY3Rpb24gaGFuZGxlQWJvcnQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcsIEF4aW9zRXJyb3IuRUNPTk5BQk9SVEVELCBjb25maWcsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXZlbnQpIHtcbiAgICAgICAvLyBCcm93c2VycyBkZWxpdmVyIGEgUHJvZ3Jlc3NFdmVudCBpbiBYSFIgb25lcnJvclxuICAgICAgIC8vIChtZXNzYWdlIG1heSBiZSBlbXB0eTsgd2hlbiBwcmVzZW50LCBzdXJmYWNlIGl0KVxuICAgICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3QvZXJyb3JfZXZlbnRcbiAgICAgICBjb25zdCBtc2cgPSBldmVudCAmJiBldmVudC5tZXNzYWdlID8gZXZlbnQubWVzc2FnZSA6ICdOZXR3b3JrIEVycm9yJztcbiAgICAgICBjb25zdCBlcnIgPSBuZXcgQXhpb3NFcnJvcihtc2csIEF4aW9zRXJyb3IuRVJSX05FVFdPUkssIGNvbmZpZywgcmVxdWVzdCk7XG4gICAgICAgLy8gYXR0YWNoIHRoZSB1bmRlcmx5aW5nIGV2ZW50IGZvciBjb25zdW1lcnMgd2hvIHdhbnQgZGV0YWlsc1xuICAgICAgIGVyci5ldmVudCA9IGV2ZW50IHx8IG51bGw7XG4gICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcbiAgICBcbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIGxldCB0aW1lb3V0RXJyb3JNZXNzYWdlID0gX2NvbmZpZy50aW1lb3V0ID8gJ3RpbWVvdXQgb2YgJyArIF9jb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcgOiAndGltZW91dCBleGNlZWRlZCc7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uYWwgPSBfY29uZmlnLnRyYW5zaXRpb25hbCB8fCB0cmFuc2l0aW9uYWxEZWZhdWx0cztcbiAgICAgIGlmIChfY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IF9jb25maWcudGltZW91dEVycm9yTWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSxcbiAgICAgICAgdHJhbnNpdGlvbmFsLmNsYXJpZnlUaW1lb3V0RXJyb3IgPyBBeGlvc0Vycm9yLkVUSU1FRE9VVCA6IEF4aW9zRXJyb3IuRUNPTk5BQk9SVEVELFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICByZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkICYmIHJlcXVlc3RIZWFkZXJzLnNldENvbnRlbnRUeXBlKG51bGwpO1xuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMudG9KU09OKCksIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKF9jb25maWcud2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSAhIV9jb25maWcud2l0aENyZWRlbnRpYWxzO1xuICAgIH1cblxuICAgIC8vIEFkZCByZXNwb25zZVR5cGUgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAocmVzcG9uc2VUeXBlICYmIHJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IF9jb25maWcucmVzcG9uc2VUeXBlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAob25Eb3dubG9hZFByb2dyZXNzKSB7XG4gICAgICAoW2Rvd25sb2FkVGhyb3R0bGVkLCBmbHVzaERvd25sb2FkXSA9IHByb2dyZXNzRXZlbnRSZWR1Y2VyKG9uRG93bmxvYWRQcm9ncmVzcywgdHJ1ZSkpO1xuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGRvd25sb2FkVGhyb3R0bGVkKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmIChvblVwbG9hZFByb2dyZXNzICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICAoW3VwbG9hZFRocm90dGxlZCwgZmx1c2hVcGxvYWRdID0gcHJvZ3Jlc3NFdmVudFJlZHVjZXIob25VcGxvYWRQcm9ncmVzcykpO1xuXG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHVwbG9hZFRocm90dGxlZCk7XG5cbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCBmbHVzaFVwbG9hZCk7XG4gICAgfVxuXG4gICAgaWYgKF9jb25maWcuY2FuY2VsVG9rZW4gfHwgX2NvbmZpZy5zaWduYWwpIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgICBvbkNhbmNlbGVkID0gY2FuY2VsID0+IHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlamVjdCghY2FuY2VsIHx8IGNhbmNlbC50eXBlID8gbmV3IENhbmNlbGVkRXJyb3IobnVsbCwgY29uZmlnLCByZXF1ZXN0KSA6IGNhbmNlbCk7XG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBfY29uZmlnLmNhbmNlbFRva2VuICYmIF9jb25maWcuY2FuY2VsVG9rZW4uc3Vic2NyaWJlKG9uQ2FuY2VsZWQpO1xuICAgICAgaWYgKF9jb25maWcuc2lnbmFsKSB7XG4gICAgICAgIF9jb25maWcuc2lnbmFsLmFib3J0ZWQgPyBvbkNhbmNlbGVkKCkgOiBfY29uZmlnLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQ2FuY2VsZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHByb3RvY29sID0gcGFyc2VQcm90b2NvbChfY29uZmlnLnVybCk7XG5cbiAgICBpZiAocHJvdG9jb2wgJiYgcGxhdGZvcm0ucHJvdG9jb2xzLmluZGV4T2YocHJvdG9jb2wpID09PSAtMSkge1xuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKCdVbnN1cHBvcnRlZCBwcm90b2NvbCAnICsgcHJvdG9jb2wgKyAnOicsIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVFVRVNULCBjb25maWcpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEgfHwgbnVsbCk7XG4gIH0pO1xufVxuIiwgImltcG9ydCBDYW5jZWxlZEVycm9yIGZyb20gXCIuLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qc1wiO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSBcIi4uL2NvcmUvQXhpb3NFcnJvci5qc1wiO1xuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuY29uc3QgY29tcG9zZVNpZ25hbHMgPSAoc2lnbmFscywgdGltZW91dCkgPT4ge1xuICBjb25zdCB7bGVuZ3RofSA9IChzaWduYWxzID0gc2lnbmFscyA/IHNpZ25hbHMuZmlsdGVyKEJvb2xlYW4pIDogW10pO1xuXG4gIGlmICh0aW1lb3V0IHx8IGxlbmd0aCkge1xuICAgIGxldCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXG4gICAgbGV0IGFib3J0ZWQ7XG5cbiAgICBjb25zdCBvbmFib3J0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKCFhYm9ydGVkKSB7XG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICBjb25zdCBlcnIgPSByZWFzb24gaW5zdGFuY2VvZiBFcnJvciA/IHJlYXNvbiA6IHRoaXMucmVhc29uO1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KGVyciBpbnN0YW5jZW9mIEF4aW9zRXJyb3IgPyBlcnIgOiBuZXcgQ2FuY2VsZWRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogZXJyKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHRpbWVyID0gdGltZW91dCAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgIG9uYWJvcnQobmV3IEF4aW9zRXJyb3IoYHRpbWVvdXQgJHt0aW1lb3V0fSBvZiBtcyBleGNlZWRlZGAsIEF4aW9zRXJyb3IuRVRJTUVET1VUKSlcbiAgICB9LCB0aW1lb3V0KVxuXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICBpZiAoc2lnbmFscykge1xuICAgICAgICB0aW1lciAmJiBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgIHNpZ25hbHMuZm9yRWFjaChzaWduYWwgPT4ge1xuICAgICAgICAgIHNpZ25hbC51bnN1YnNjcmliZSA/IHNpZ25hbC51bnN1YnNjcmliZShvbmFib3J0KSA6IHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uYWJvcnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2lnbmFscyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2lnbmFscy5mb3JFYWNoKChzaWduYWwpID0+IHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uYWJvcnQpKTtcblxuICAgIGNvbnN0IHtzaWduYWx9ID0gY29udHJvbGxlcjtcblxuICAgIHNpZ25hbC51bnN1YnNjcmliZSA9ICgpID0+IHV0aWxzLmFzYXAodW5zdWJzY3JpYmUpO1xuXG4gICAgcmV0dXJuIHNpZ25hbDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb3NlU2lnbmFscztcbiIsICJcbmV4cG9ydCBjb25zdCBzdHJlYW1DaHVuayA9IGZ1bmN0aW9uKiAoY2h1bmssIGNodW5rU2l6ZSkge1xuICBsZXQgbGVuID0gY2h1bmsuYnl0ZUxlbmd0aDtcblxuICBpZiAoIWNodW5rU2l6ZSB8fCBsZW4gPCBjaHVua1NpemUpIHtcbiAgICB5aWVsZCBjaHVuaztcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgcG9zID0gMDtcbiAgbGV0IGVuZDtcblxuICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgZW5kID0gcG9zICsgY2h1bmtTaXplO1xuICAgIHlpZWxkIGNodW5rLnNsaWNlKHBvcywgZW5kKTtcbiAgICBwb3MgPSBlbmQ7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJlYWRCeXRlcyA9IGFzeW5jIGZ1bmN0aW9uKiAoaXRlcmFibGUsIGNodW5rU2l6ZSkge1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlYWRTdHJlYW0oaXRlcmFibGUpKSB7XG4gICAgeWllbGQqIHN0cmVhbUNodW5rKGNodW5rLCBjaHVua1NpemUpO1xuICB9XG59XG5cbmNvbnN0IHJlYWRTdHJlYW0gPSBhc3luYyBmdW5jdGlvbiogKHN0cmVhbSkge1xuICBpZiAoc3RyZWFtW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSkge1xuICAgIHlpZWxkKiBzdHJlYW07XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICB0cnkge1xuICAgIGZvciAoOzspIHtcbiAgICAgIGNvbnN0IHtkb25lLCB2YWx1ZX0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB5aWVsZCB2YWx1ZTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgcmVhZGVyLmNhbmNlbCgpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB0cmFja1N0cmVhbSA9IChzdHJlYW0sIGNodW5rU2l6ZSwgb25Qcm9ncmVzcywgb25GaW5pc2gpID0+IHtcbiAgY29uc3QgaXRlcmF0b3IgPSByZWFkQnl0ZXMoc3RyZWFtLCBjaHVua1NpemUpO1xuXG4gIGxldCBieXRlcyA9IDA7XG4gIGxldCBkb25lO1xuICBsZXQgX29uRmluaXNoID0gKGUpID0+IHtcbiAgICBpZiAoIWRvbmUpIHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgb25GaW5pc2ggJiYgb25GaW5pc2goZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7ZG9uZSwgdmFsdWV9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICBfb25GaW5pc2goKTtcbiAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxlbiA9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgICAgbGV0IGxvYWRlZEJ5dGVzID0gYnl0ZXMgKz0gbGVuO1xuICAgICAgICAgIG9uUHJvZ3Jlc3MobG9hZGVkQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9vbkZpbmlzaChlcnIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSxcbiAgICBjYW5jZWwocmVhc29uKSB7XG4gICAgICBfb25GaW5pc2gocmVhc29uKTtcbiAgICAgIHJldHVybiBpdGVyYXRvci5yZXR1cm4oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBoaWdoV2F0ZXJNYXJrOiAyXG4gIH0pXG59XG4iLCAiaW1wb3J0IHBsYXRmb3JtIGZyb20gXCIuLi9wbGF0Zm9ybS9pbmRleC5qc1wiO1xuaW1wb3J0IHV0aWxzIGZyb20gXCIuLi91dGlscy5qc1wiO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSBcIi4uL2NvcmUvQXhpb3NFcnJvci5qc1wiO1xuaW1wb3J0IGNvbXBvc2VTaWduYWxzIGZyb20gXCIuLi9oZWxwZXJzL2NvbXBvc2VTaWduYWxzLmpzXCI7XG5pbXBvcnQge3RyYWNrU3RyZWFtfSBmcm9tIFwiLi4vaGVscGVycy90cmFja1N0cmVhbS5qc1wiO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tIFwiLi4vY29yZS9BeGlvc0hlYWRlcnMuanNcIjtcbmltcG9ydCB7cHJvZ3Jlc3NFdmVudFJlZHVjZXIsIHByb2dyZXNzRXZlbnREZWNvcmF0b3IsIGFzeW5jRGVjb3JhdG9yfSBmcm9tIFwiLi4vaGVscGVycy9wcm9ncmVzc0V2ZW50UmVkdWNlci5qc1wiO1xuaW1wb3J0IHJlc29sdmVDb25maWcgZnJvbSBcIi4uL2hlbHBlcnMvcmVzb2x2ZUNvbmZpZy5qc1wiO1xuaW1wb3J0IHNldHRsZSBmcm9tIFwiLi4vY29yZS9zZXR0bGUuanNcIjtcblxuY29uc3QgREVGQVVMVF9DSFVOS19TSVpFID0gNjQgKiAxMDI0O1xuXG5jb25zdCB7aXNGdW5jdGlvbn0gPSB1dGlscztcblxuY29uc3QgZ2xvYmFsRmV0Y2hBUEkgPSAoKHtSZXF1ZXN0LCBSZXNwb25zZX0pID0+ICh7XG4gIFJlcXVlc3QsIFJlc3BvbnNlXG59KSkodXRpbHMuZ2xvYmFsKTtcblxuY29uc3Qge1xuICBSZWFkYWJsZVN0cmVhbSwgVGV4dEVuY29kZXJcbn0gPSB1dGlscy5nbG9iYWw7XG5cblxuY29uc3QgdGVzdCA9IChmbiwgLi4uYXJncykgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiAhIWZuKC4uLmFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuY29uc3QgZmFjdG9yeSA9IChlbnYpID0+IHtcbiAgZW52ID0gdXRpbHMubWVyZ2UuY2FsbCh7XG4gICAgc2tpcFVuZGVmaW5lZDogdHJ1ZVxuICB9LCBnbG9iYWxGZXRjaEFQSSwgZW52KTtcblxuICBjb25zdCB7ZmV0Y2g6IGVudkZldGNoLCBSZXF1ZXN0LCBSZXNwb25zZX0gPSBlbnY7XG4gIGNvbnN0IGlzRmV0Y2hTdXBwb3J0ZWQgPSBlbnZGZXRjaCA/IGlzRnVuY3Rpb24oZW52RmV0Y2gpIDogdHlwZW9mIGZldGNoID09PSAnZnVuY3Rpb24nO1xuICBjb25zdCBpc1JlcXVlc3RTdXBwb3J0ZWQgPSBpc0Z1bmN0aW9uKFJlcXVlc3QpO1xuICBjb25zdCBpc1Jlc3BvbnNlU3VwcG9ydGVkID0gaXNGdW5jdGlvbihSZXNwb25zZSk7XG5cbiAgaWYgKCFpc0ZldGNoU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgaXNSZWFkYWJsZVN0cmVhbVN1cHBvcnRlZCA9IGlzRmV0Y2hTdXBwb3J0ZWQgJiYgaXNGdW5jdGlvbihSZWFkYWJsZVN0cmVhbSk7XG5cbiAgY29uc3QgZW5jb2RlVGV4dCA9IGlzRmV0Y2hTdXBwb3J0ZWQgJiYgKHR5cGVvZiBUZXh0RW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAoKGVuY29kZXIpID0+IChzdHIpID0+IGVuY29kZXIuZW5jb2RlKHN0cikpKG5ldyBUZXh0RW5jb2RlcigpKSA6XG4gICAgICBhc3luYyAoc3RyKSA9PiBuZXcgVWludDhBcnJheShhd2FpdCBuZXcgUmVxdWVzdChzdHIpLmFycmF5QnVmZmVyKCkpXG4gICk7XG5cbiAgY29uc3Qgc3VwcG9ydHNSZXF1ZXN0U3RyZWFtID0gaXNSZXF1ZXN0U3VwcG9ydGVkICYmIGlzUmVhZGFibGVTdHJlYW1TdXBwb3J0ZWQgJiYgdGVzdCgoKSA9PiB7XG4gICAgbGV0IGR1cGxleEFjY2Vzc2VkID0gZmFsc2U7XG5cbiAgICBjb25zdCBoYXNDb250ZW50VHlwZSA9IG5ldyBSZXF1ZXN0KHBsYXRmb3JtLm9yaWdpbiwge1xuICAgICAgYm9keTogbmV3IFJlYWRhYmxlU3RyZWFtKCksXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGdldCBkdXBsZXgoKSB7XG4gICAgICAgIGR1cGxleEFjY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICdoYWxmJztcbiAgICAgIH0sXG4gICAgfSkuaGVhZGVycy5oYXMoJ0NvbnRlbnQtVHlwZScpO1xuXG4gICAgcmV0dXJuIGR1cGxleEFjY2Vzc2VkICYmICFoYXNDb250ZW50VHlwZTtcbiAgfSk7XG5cbiAgY29uc3Qgc3VwcG9ydHNSZXNwb25zZVN0cmVhbSA9IGlzUmVzcG9uc2VTdXBwb3J0ZWQgJiYgaXNSZWFkYWJsZVN0cmVhbVN1cHBvcnRlZCAmJlxuICAgIHRlc3QoKCkgPT4gdXRpbHMuaXNSZWFkYWJsZVN0cmVhbShuZXcgUmVzcG9uc2UoJycpLmJvZHkpKTtcblxuICBjb25zdCByZXNvbHZlcnMgPSB7XG4gICAgc3RyZWFtOiBzdXBwb3J0c1Jlc3BvbnNlU3RyZWFtICYmICgocmVzKSA9PiByZXMuYm9keSlcbiAgfTtcblxuICBpc0ZldGNoU3VwcG9ydGVkICYmICgoKCkgPT4ge1xuICAgIFsndGV4dCcsICdhcnJheUJ1ZmZlcicsICdibG9iJywgJ2Zvcm1EYXRhJywgJ3N0cmVhbSddLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAhcmVzb2x2ZXJzW3R5cGVdICYmIChyZXNvbHZlcnNbdHlwZV0gPSAocmVzLCBjb25maWcpID0+IHtcbiAgICAgICAgbGV0IG1ldGhvZCA9IHJlcyAmJiByZXNbdHlwZV07XG5cbiAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBtZXRob2QuY2FsbChyZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoYFJlc3BvbnNlIHR5cGUgJyR7dHlwZX0nIGlzIG5vdCBzdXBwb3J0ZWRgLCBBeGlvc0Vycm9yLkVSUl9OT1RfU1VQUE9SVCwgY29uZmlnKTtcbiAgICAgIH0pXG4gICAgfSk7XG4gIH0pKCkpO1xuXG4gIGNvbnN0IGdldEJvZHlMZW5ndGggPSBhc3luYyAoYm9keSkgPT4ge1xuICAgIGlmIChib2R5ID09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0Jsb2IoYm9keSkpIHtcbiAgICAgIHJldHVybiBib2R5LnNpemU7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzU3BlY0NvbXBsaWFudEZvcm0oYm9keSkpIHtcbiAgICAgIGNvbnN0IF9yZXF1ZXN0ID0gbmV3IFJlcXVlc3QocGxhdGZvcm0ub3JpZ2luLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5LFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gKGF3YWl0IF9yZXF1ZXN0LmFycmF5QnVmZmVyKCkpLmJ5dGVMZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpIHx8IHV0aWxzLmlzQXJyYXlCdWZmZXIoYm9keSkpIHtcbiAgICAgIHJldHVybiBib2R5LmJ5dGVMZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGJvZHkpKSB7XG4gICAgICBib2R5ID0gYm9keSArICcnO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc1N0cmluZyhib2R5KSkge1xuICAgICAgcmV0dXJuIChhd2FpdCBlbmNvZGVUZXh0KGJvZHkpKS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVCb2R5TGVuZ3RoID0gYXN5bmMgKGhlYWRlcnMsIGJvZHkpID0+IHtcbiAgICBjb25zdCBsZW5ndGggPSB1dGlscy50b0Zpbml0ZU51bWJlcihoZWFkZXJzLmdldENvbnRlbnRMZW5ndGgoKSk7XG5cbiAgICByZXR1cm4gbGVuZ3RoID09IG51bGwgPyBnZXRCb2R5TGVuZ3RoKGJvZHkpIDogbGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIGFzeW5jIChjb25maWcpID0+IHtcbiAgICBsZXQge1xuICAgICAgdXJsLFxuICAgICAgbWV0aG9kLFxuICAgICAgZGF0YSxcbiAgICAgIHNpZ25hbCxcbiAgICAgIGNhbmNlbFRva2VuLFxuICAgICAgdGltZW91dCxcbiAgICAgIG9uRG93bmxvYWRQcm9ncmVzcyxcbiAgICAgIG9uVXBsb2FkUHJvZ3Jlc3MsXG4gICAgICByZXNwb25zZVR5cGUsXG4gICAgICBoZWFkZXJzLFxuICAgICAgd2l0aENyZWRlbnRpYWxzID0gJ3NhbWUtb3JpZ2luJyxcbiAgICAgIGZldGNoT3B0aW9uc1xuICAgIH0gPSByZXNvbHZlQ29uZmlnKGNvbmZpZyk7XG5cbiAgICBsZXQgX2ZldGNoID0gZW52RmV0Y2ggfHwgZmV0Y2g7XG5cbiAgICByZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGUgPyAocmVzcG9uc2VUeXBlICsgJycpLnRvTG93ZXJDYXNlKCkgOiAndGV4dCc7XG5cbiAgICBsZXQgY29tcG9zZWRTaWduYWwgPSBjb21wb3NlU2lnbmFscyhbc2lnbmFsLCBjYW5jZWxUb2tlbiAmJiBjYW5jZWxUb2tlbi50b0Fib3J0U2lnbmFsKCldLCB0aW1lb3V0KTtcblxuICAgIGxldCByZXF1ZXN0ID0gbnVsbDtcblxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gY29tcG9zZWRTaWduYWwgJiYgY29tcG9zZWRTaWduYWwudW5zdWJzY3JpYmUgJiYgKCgpID0+IHtcbiAgICAgIGNvbXBvc2VkU2lnbmFsLnVuc3Vic2NyaWJlKCk7XG4gICAgfSk7XG5cbiAgICBsZXQgcmVxdWVzdENvbnRlbnRMZW5ndGg7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKFxuICAgICAgICBvblVwbG9hZFByb2dyZXNzICYmIHN1cHBvcnRzUmVxdWVzdFN0cmVhbSAmJiBtZXRob2QgIT09ICdnZXQnICYmIG1ldGhvZCAhPT0gJ2hlYWQnICYmXG4gICAgICAgIChyZXF1ZXN0Q29udGVudExlbmd0aCA9IGF3YWl0IHJlc29sdmVCb2R5TGVuZ3RoKGhlYWRlcnMsIGRhdGEpKSAhPT0gMFxuICAgICAgKSB7XG4gICAgICAgIGxldCBfcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGJvZHk6IGRhdGEsXG4gICAgICAgICAgZHVwbGV4OiBcImhhbGZcIlxuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgY29udGVudFR5cGVIZWFkZXI7XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgJiYgKGNvbnRlbnRUeXBlSGVhZGVyID0gX3JlcXVlc3QuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSkge1xuICAgICAgICAgIGhlYWRlcnMuc2V0Q29udGVudFR5cGUoY29udGVudFR5cGVIZWFkZXIpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3JlcXVlc3QuYm9keSkge1xuICAgICAgICAgIGNvbnN0IFtvblByb2dyZXNzLCBmbHVzaF0gPSBwcm9ncmVzc0V2ZW50RGVjb3JhdG9yKFxuICAgICAgICAgICAgcmVxdWVzdENvbnRlbnRMZW5ndGgsXG4gICAgICAgICAgICBwcm9ncmVzc0V2ZW50UmVkdWNlcihhc3luY0RlY29yYXRvcihvblVwbG9hZFByb2dyZXNzKSlcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgZGF0YSA9IHRyYWNrU3RyZWFtKF9yZXF1ZXN0LmJvZHksIERFRkFVTFRfQ0hVTktfU0laRSwgb25Qcm9ncmVzcywgZmx1c2gpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdXRpbHMuaXNTdHJpbmcod2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgICB3aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHMgPyAnaW5jbHVkZScgOiAnb21pdCc7XG4gICAgICB9XG5cbiAgICAgIC8vIENsb3VkZmxhcmUgV29ya2VycyB0aHJvd3Mgd2hlbiBjcmVkZW50aWFscyBhcmUgZGVmaW5lZFxuICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jbG91ZGZsYXJlL3dvcmtlcmQvaXNzdWVzLzkwMlxuICAgICAgY29uc3QgaXNDcmVkZW50aWFsc1N1cHBvcnRlZCA9IGlzUmVxdWVzdFN1cHBvcnRlZCAmJiBcImNyZWRlbnRpYWxzXCIgaW4gUmVxdWVzdC5wcm90b3R5cGU7XG5cbiAgICAgIGNvbnN0IHJlc29sdmVkT3B0aW9ucyA9IHtcbiAgICAgICAgLi4uZmV0Y2hPcHRpb25zLFxuICAgICAgICBzaWduYWw6IGNvbXBvc2VkU2lnbmFsLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZC50b1VwcGVyQ2FzZSgpLFxuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLm5vcm1hbGl6ZSgpLnRvSlNPTigpLFxuICAgICAgICBib2R5OiBkYXRhLFxuICAgICAgICBkdXBsZXg6IFwiaGFsZlwiLFxuICAgICAgICBjcmVkZW50aWFsczogaXNDcmVkZW50aWFsc1N1cHBvcnRlZCA/IHdpdGhDcmVkZW50aWFscyA6IHVuZGVmaW5lZFxuICAgICAgfTtcblxuICAgICAgcmVxdWVzdCA9IGlzUmVxdWVzdFN1cHBvcnRlZCAmJiBuZXcgUmVxdWVzdCh1cmwsIHJlc29sdmVkT3B0aW9ucyk7XG5cbiAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IChpc1JlcXVlc3RTdXBwb3J0ZWQgPyBfZmV0Y2gocmVxdWVzdCwgZmV0Y2hPcHRpb25zKSA6IF9mZXRjaCh1cmwsIHJlc29sdmVkT3B0aW9ucykpO1xuXG4gICAgICBjb25zdCBpc1N0cmVhbVJlc3BvbnNlID0gc3VwcG9ydHNSZXNwb25zZVN0cmVhbSAmJiAocmVzcG9uc2VUeXBlID09PSAnc3RyZWFtJyB8fCByZXNwb25zZVR5cGUgPT09ICdyZXNwb25zZScpO1xuXG4gICAgICBpZiAoc3VwcG9ydHNSZXNwb25zZVN0cmVhbSAmJiAob25Eb3dubG9hZFByb2dyZXNzIHx8IChpc1N0cmVhbVJlc3BvbnNlICYmIHVuc3Vic2NyaWJlKSkpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuXG4gICAgICAgIFsnc3RhdHVzJywgJ3N0YXR1c1RleHQnLCAnaGVhZGVycyddLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgb3B0aW9uc1twcm9wXSA9IHJlc3BvbnNlW3Byb3BdO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXNwb25zZUNvbnRlbnRMZW5ndGggPSB1dGlscy50b0Zpbml0ZU51bWJlcihyZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC1sZW5ndGgnKSk7XG5cbiAgICAgICAgY29uc3QgW29uUHJvZ3Jlc3MsIGZsdXNoXSA9IG9uRG93bmxvYWRQcm9ncmVzcyAmJiBwcm9ncmVzc0V2ZW50RGVjb3JhdG9yKFxuICAgICAgICAgIHJlc3BvbnNlQ29udGVudExlbmd0aCxcbiAgICAgICAgICBwcm9ncmVzc0V2ZW50UmVkdWNlcihhc3luY0RlY29yYXRvcihvbkRvd25sb2FkUHJvZ3Jlc3MpLCB0cnVlKVxuICAgICAgICApIHx8IFtdO1xuXG4gICAgICAgIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKFxuICAgICAgICAgIHRyYWNrU3RyZWFtKHJlc3BvbnNlLmJvZHksIERFRkFVTFRfQ0hVTktfU0laRSwgb25Qcm9ncmVzcywgKCkgPT4ge1xuICAgICAgICAgICAgZmx1c2ggJiYgZmx1c2goKTtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlICYmIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGUgfHwgJ3RleHQnO1xuXG4gICAgICBsZXQgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzb2x2ZXJzW3V0aWxzLmZpbmRLZXkocmVzb2x2ZXJzLCByZXNwb25zZVR5cGUpIHx8ICd0ZXh0J10ocmVzcG9uc2UsIGNvbmZpZyk7XG5cbiAgICAgICFpc1N0cmVhbVJlc3BvbnNlICYmIHVuc3Vic2NyaWJlICYmIHVuc3Vic2NyaWJlKCk7XG5cbiAgICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHtcbiAgICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgICAgaGVhZGVyczogQXhpb3NIZWFkZXJzLmZyb20ocmVzcG9uc2UuaGVhZGVycyksXG4gICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgcmVxdWVzdFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHVuc3Vic2NyaWJlICYmIHVuc3Vic2NyaWJlKCk7XG5cbiAgICAgIGlmIChlcnIgJiYgZXJyLm5hbWUgPT09ICdUeXBlRXJyb3InICYmIC9Mb2FkIGZhaWxlZHxmZXRjaC9pLnRlc3QoZXJyLm1lc3NhZ2UpKSB7XG4gICAgICAgIHRocm93IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgbmV3IEF4aW9zRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBBeGlvc0Vycm9yLkVSUl9ORVRXT1JLLCBjb25maWcsIHJlcXVlc3QpLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNhdXNlOiBlcnIuY2F1c2UgfHwgZXJyXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHRocm93IEF4aW9zRXJyb3IuZnJvbShlcnIsIGVyciAmJiBlcnIuY29kZSwgY29uZmlnLCByZXF1ZXN0KTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgc2VlZENhY2hlID0gbmV3IE1hcCgpO1xuXG5leHBvcnQgY29uc3QgZ2V0RmV0Y2ggPSAoY29uZmlnKSA9PiB7XG4gIGxldCBlbnYgPSAoY29uZmlnICYmIGNvbmZpZy5lbnYpIHx8IHt9O1xuICBjb25zdCB7ZmV0Y2gsIFJlcXVlc3QsIFJlc3BvbnNlfSA9IGVudjtcbiAgY29uc3Qgc2VlZHMgPSBbXG4gICAgUmVxdWVzdCwgUmVzcG9uc2UsIGZldGNoXG4gIF07XG5cbiAgbGV0IGxlbiA9IHNlZWRzLmxlbmd0aCwgaSA9IGxlbixcbiAgICBzZWVkLCB0YXJnZXQsIG1hcCA9IHNlZWRDYWNoZTtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgc2VlZCA9IHNlZWRzW2ldO1xuICAgIHRhcmdldCA9IG1hcC5nZXQoc2VlZCk7XG5cbiAgICB0YXJnZXQgPT09IHVuZGVmaW5lZCAmJiBtYXAuc2V0KHNlZWQsIHRhcmdldCA9IChpID8gbmV3IE1hcCgpIDogZmFjdG9yeShlbnYpKSlcblxuICAgIG1hcCA9IHRhcmdldDtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5jb25zdCBhZGFwdGVyID0gZ2V0RmV0Y2goKTtcblxuZXhwb3J0IGRlZmF1bHQgYWRhcHRlcjtcbiIsICJpbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IGh0dHBBZGFwdGVyIGZyb20gJy4vaHR0cC5qcyc7XG5pbXBvcnQgeGhyQWRhcHRlciBmcm9tICcuL3hoci5qcyc7XG5pbXBvcnQgKiBhcyBmZXRjaEFkYXB0ZXIgZnJvbSAnLi9mZXRjaC5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tIFwiLi4vY29yZS9BeGlvc0Vycm9yLmpzXCI7XG5cbi8qKlxuICogS25vd24gYWRhcHRlcnMgbWFwcGluZy5cbiAqIFByb3ZpZGVzIGVudmlyb25tZW50LXNwZWNpZmljIGFkYXB0ZXJzIGZvciBBeGlvczpcbiAqIC0gYGh0dHBgIGZvciBOb2RlLmpzXG4gKiAtIGB4aHJgIGZvciBicm93c2Vyc1xuICogLSBgZmV0Y2hgIGZvciBmZXRjaCBBUEktYmFzZWQgcmVxdWVzdHNcbiAqIFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIEZ1bmN0aW9ufE9iamVjdD59XG4gKi9cbmNvbnN0IGtub3duQWRhcHRlcnMgPSB7XG4gIGh0dHA6IGh0dHBBZGFwdGVyLFxuICB4aHI6IHhockFkYXB0ZXIsXG4gIGZldGNoOiB7XG4gICAgZ2V0OiBmZXRjaEFkYXB0ZXIuZ2V0RmV0Y2gsXG4gIH1cbn07XG5cbi8vIEFzc2lnbiBhZGFwdGVyIG5hbWVzIGZvciBlYXNpZXIgZGVidWdnaW5nIGFuZCBpZGVudGlmaWNhdGlvblxudXRpbHMuZm9yRWFjaChrbm93bkFkYXB0ZXJzLCAoZm4sIHZhbHVlKSA9PiB7XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICduYW1lJywgeyB2YWx1ZSB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnYWRhcHRlck5hbWUnLCB7IHZhbHVlIH0pO1xuICB9XG59KTtcblxuLyoqXG4gKiBSZW5kZXIgYSByZWplY3Rpb24gcmVhc29uIHN0cmluZyBmb3IgdW5rbm93biBvciB1bnN1cHBvcnRlZCBhZGFwdGVyc1xuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCByZW5kZXJSZWFzb24gPSAocmVhc29uKSA9PiBgLSAke3JlYXNvbn1gO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBhZGFwdGVyIGlzIHJlc29sdmVkIChmdW5jdGlvbiwgbnVsbCwgb3IgZmFsc2UpXG4gKiBcbiAqIEBwYXJhbSB7RnVuY3Rpb258bnVsbHxmYWxzZX0gYWRhcHRlclxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzUmVzb2x2ZWRIYW5kbGUgPSAoYWRhcHRlcikgPT4gdXRpbHMuaXNGdW5jdGlvbihhZGFwdGVyKSB8fCBhZGFwdGVyID09PSBudWxsIHx8IGFkYXB0ZXIgPT09IGZhbHNlO1xuXG4vKipcbiAqIEdldCB0aGUgZmlyc3Qgc3VpdGFibGUgYWRhcHRlciBmcm9tIHRoZSBwcm92aWRlZCBsaXN0LlxuICogVHJpZXMgZWFjaCBhZGFwdGVyIGluIG9yZGVyIHVudGlsIGEgc3VwcG9ydGVkIG9uZSBpcyBmb3VuZC5cbiAqIFRocm93cyBhbiBBeGlvc0Vycm9yIGlmIG5vIGFkYXB0ZXIgaXMgc3VpdGFibGUuXG4gKiBcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfEZ1bmN0aW9uPnxzdHJpbmd8RnVuY3Rpb259IGFkYXB0ZXJzIC0gQWRhcHRlcihzKSBieSBuYW1lIG9yIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIEF4aW9zIHJlcXVlc3QgY29uZmlndXJhdGlvblxuICogQHRocm93cyB7QXhpb3NFcnJvcn0gSWYgbm8gc3VpdGFibGUgYWRhcHRlciBpcyBhdmFpbGFibGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIHJlc29sdmVkIGFkYXB0ZXIgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZ2V0QWRhcHRlcihhZGFwdGVycywgY29uZmlnKSB7XG4gIGFkYXB0ZXJzID0gdXRpbHMuaXNBcnJheShhZGFwdGVycykgPyBhZGFwdGVycyA6IFthZGFwdGVyc107XG5cbiAgY29uc3QgeyBsZW5ndGggfSA9IGFkYXB0ZXJzO1xuICBsZXQgbmFtZU9yQWRhcHRlcjtcbiAgbGV0IGFkYXB0ZXI7XG5cbiAgY29uc3QgcmVqZWN0ZWRSZWFzb25zID0ge307XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIG5hbWVPckFkYXB0ZXIgPSBhZGFwdGVyc1tpXTtcbiAgICBsZXQgaWQ7XG5cbiAgICBhZGFwdGVyID0gbmFtZU9yQWRhcHRlcjtcblxuICAgIGlmICghaXNSZXNvbHZlZEhhbmRsZShuYW1lT3JBZGFwdGVyKSkge1xuICAgICAgYWRhcHRlciA9IGtub3duQWRhcHRlcnNbKGlkID0gU3RyaW5nKG5hbWVPckFkYXB0ZXIpKS50b0xvd2VyQ2FzZSgpXTtcblxuICAgICAgaWYgKGFkYXB0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihgVW5rbm93biBhZGFwdGVyICcke2lkfSdgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWRhcHRlciAmJiAodXRpbHMuaXNGdW5jdGlvbihhZGFwdGVyKSB8fCAoYWRhcHRlciA9IGFkYXB0ZXIuZ2V0KGNvbmZpZykpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmVqZWN0ZWRSZWFzb25zW2lkIHx8ICcjJyArIGldID0gYWRhcHRlcjtcbiAgfVxuXG4gIGlmICghYWRhcHRlcikge1xuICAgIGNvbnN0IHJlYXNvbnMgPSBPYmplY3QuZW50cmllcyhyZWplY3RlZFJlYXNvbnMpXG4gICAgICAubWFwKChbaWQsIHN0YXRlXSkgPT4gYGFkYXB0ZXIgJHtpZH0gYCArXG4gICAgICAgIChzdGF0ZSA9PT0gZmFsc2UgPyAnaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgZW52aXJvbm1lbnQnIDogJ2lzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGJ1aWxkJylcbiAgICAgICk7XG5cbiAgICBsZXQgcyA9IGxlbmd0aCA/XG4gICAgICAocmVhc29ucy5sZW5ndGggPiAxID8gJ3NpbmNlIDpcXG4nICsgcmVhc29ucy5tYXAocmVuZGVyUmVhc29uKS5qb2luKCdcXG4nKSA6ICcgJyArIHJlbmRlclJlYXNvbihyZWFzb25zWzBdKSkgOlxuICAgICAgJ2FzIG5vIGFkYXB0ZXIgc3BlY2lmaWVkJztcblxuICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKFxuICAgICAgYFRoZXJlIGlzIG5vIHN1aXRhYmxlIGFkYXB0ZXIgdG8gZGlzcGF0Y2ggdGhlIHJlcXVlc3QgYCArIHMsXG4gICAgICAnRVJSX05PVF9TVVBQT1JUJ1xuICAgICk7XG4gIH1cblxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxuLyoqXG4gKiBFeHBvcnRzIEF4aW9zIGFkYXB0ZXJzIGFuZCB1dGlsaXR5IHRvIHJlc29sdmUgYW4gYWRhcHRlclxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBSZXNvbHZlIGFuIGFkYXB0ZXIgZnJvbSBhIGxpc3Qgb2YgYWRhcHRlciBuYW1lcyBvciBmdW5jdGlvbnMuXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIGdldEFkYXB0ZXIsXG5cbiAgLyoqXG4gICAqIEV4cG9zZXMgYWxsIGtub3duIGFkYXB0ZXJzXG4gICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBGdW5jdGlvbnxPYmplY3Q+fVxuICAgKi9cbiAgYWRhcHRlcnM6IGtub3duQWRhcHRlcnNcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdHJhbnNmb3JtRGF0YSBmcm9tICcuL3RyYW5zZm9ybURhdGEuanMnO1xuaW1wb3J0IGlzQ2FuY2VsIGZyb20gJy4uL2NhbmNlbC9pc0NhbmNlbC5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vZGVmYXVsdHMvaW5kZXguanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMnO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tICcuLi9jb3JlL0F4aW9zSGVhZGVycy5qcyc7XG5pbXBvcnQgYWRhcHRlcnMgZnJvbSBcIi4uL2FkYXB0ZXJzL2FkYXB0ZXJzLmpzXCI7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGVkRXJyb3JgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cblxuICBpZiAoY29uZmlnLnNpZ25hbCAmJiBjb25maWcuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgQ2FuY2VsZWRFcnJvcihudWxsLCBjb25maWcpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgY29uZmlnLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShjb25maWcuaGVhZGVycyk7XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICBjb25maWcsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICBpZiAoWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLmluZGV4T2YoY29uZmlnLm1ldGhvZCkgIT09IC0xKSB7XG4gICAgY29uZmlnLmhlYWRlcnMuc2V0Q29udGVudFR5cGUoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsIGZhbHNlKTtcbiAgfVxuXG4gIGNvbnN0IGFkYXB0ZXIgPSBhZGFwdGVycy5nZXRBZGFwdGVyKGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXIsIGNvbmZpZyk7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICBjb25maWcsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICByZXNwb25zZVxuICAgICk7XG5cbiAgICByZXNwb25zZS5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20ocmVzcG9uc2UuaGVhZGVycyk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20ocmVhc29uLnJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn1cbiIsICJleHBvcnQgY29uc3QgVkVSU0lPTiA9IFwiMS4xMy4yXCI7IiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtWRVJTSU9OfSBmcm9tICcuLi9lbnYvZGF0YS5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuXG5jb25zdCB2YWxpZGF0b3JzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5bJ29iamVjdCcsICdib29sZWFuJywgJ251bWJlcicsICdmdW5jdGlvbicsICdzdHJpbmcnLCAnc3ltYm9sJ10uZm9yRWFjaCgodHlwZSwgaSkgPT4ge1xuICB2YWxpZGF0b3JzW3R5cGVdID0gZnVuY3Rpb24gdmFsaWRhdG9yKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gdHlwZSB8fCAnYScgKyAoaSA8IDEgPyAnbiAnIDogJyAnKSArIHR5cGU7XG4gIH07XG59KTtcblxuY29uc3QgZGVwcmVjYXRlZFdhcm5pbmdzID0ge307XG5cbi8qKlxuICogVHJhbnNpdGlvbmFsIG9wdGlvbiB2YWxpZGF0b3JcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufGJvb2xlYW4/fSB2YWxpZGF0b3IgLSBzZXQgdG8gZmFsc2UgaWYgdGhlIHRyYW5zaXRpb25hbCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZFxuICogQHBhcmFtIHtzdHJpbmc/fSB2ZXJzaW9uIC0gZGVwcmVjYXRlZCB2ZXJzaW9uIC8gcmVtb3ZlZCBzaW5jZSB2ZXJzaW9uXG4gKiBAcGFyYW0ge3N0cmluZz99IG1lc3NhZ2UgLSBzb21lIG1lc3NhZ2Ugd2l0aCBhZGRpdGlvbmFsIGluZm9cbiAqXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cbnZhbGlkYXRvcnMudHJhbnNpdGlvbmFsID0gZnVuY3Rpb24gdHJhbnNpdGlvbmFsKHZhbGlkYXRvciwgdmVyc2lvbiwgbWVzc2FnZSkge1xuICBmdW5jdGlvbiBmb3JtYXRNZXNzYWdlKG9wdCwgZGVzYykge1xuICAgIHJldHVybiAnW0F4aW9zIHYnICsgVkVSU0lPTiArICddIFRyYW5zaXRpb25hbCBvcHRpb24gXFwnJyArIG9wdCArICdcXCcnICsgZGVzYyArIChtZXNzYWdlID8gJy4gJyArIG1lc3NhZ2UgOiAnJyk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICByZXR1cm4gKHZhbHVlLCBvcHQsIG9wdHMpID0+IHtcbiAgICBpZiAodmFsaWRhdG9yID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoXG4gICAgICAgIGZvcm1hdE1lc3NhZ2Uob3B0LCAnIGhhcyBiZWVuIHJlbW92ZWQnICsgKHZlcnNpb24gPyAnIGluICcgKyB2ZXJzaW9uIDogJycpKSxcbiAgICAgICAgQXhpb3NFcnJvci5FUlJfREVQUkVDQVRFRFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiAmJiAhZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0pIHtcbiAgICAgIGRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdID0gdHJ1ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgb3B0LFxuICAgICAgICAgICcgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2JyArIHZlcnNpb24gKyAnIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5lYXIgZnV0dXJlJ1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0b3IgPyB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0cykgOiB0cnVlO1xuICB9O1xufTtcblxudmFsaWRhdG9ycy5zcGVsbGluZyA9IGZ1bmN0aW9uIHNwZWxsaW5nKGNvcnJlY3RTcGVsbGluZykge1xuICByZXR1cm4gKHZhbHVlLCBvcHQpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybihgJHtvcHR9IGlzIGxpa2VseSBhIG1pc3NwZWxsaW5nIG9mICR7Y29ycmVjdFNwZWxsaW5nfWApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vKipcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IHNjaGVtYVxuICogQHBhcmFtIHtib29sZWFuP30gYWxsb3dVbmtub3duXG4gKlxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT05fVkFMVUUpO1xuICB9XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBjb25zdCBvcHQgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IHNjaGVtYVtvcHRdO1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1tvcHRdO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0aW9ucyk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdvcHRpb24gJyArIG9wdCArICcgbXVzdCBiZSAnICsgcmVzdWx0LCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OX1ZBTFVFKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dVbmtub3duICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCwgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgYXNzZXJ0T3B0aW9ucyxcbiAgdmFsaWRhdG9yc1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBidWlsZFVSTCBmcm9tICcuLi9oZWxwZXJzL2J1aWxkVVJMLmpzJztcbmltcG9ydCBJbnRlcmNlcHRvck1hbmFnZXIgZnJvbSAnLi9JbnRlcmNlcHRvck1hbmFnZXIuanMnO1xuaW1wb3J0IGRpc3BhdGNoUmVxdWVzdCBmcm9tICcuL2Rpc3BhdGNoUmVxdWVzdC5qcyc7XG5pbXBvcnQgbWVyZ2VDb25maWcgZnJvbSAnLi9tZXJnZUNvbmZpZy5qcyc7XG5pbXBvcnQgYnVpbGRGdWxsUGF0aCBmcm9tICcuL2J1aWxkRnVsbFBhdGguanMnO1xuaW1wb3J0IHZhbGlkYXRvciBmcm9tICcuLi9oZWxwZXJzL3ZhbGlkYXRvci5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4vQXhpb3NIZWFkZXJzLmpzJztcblxuY29uc3QgdmFsaWRhdG9ycyA9IHZhbGlkYXRvci52YWxpZGF0b3JzO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5jbGFzcyBBeGlvcyB7XG4gIGNvbnN0cnVjdG9yKGluc3RhbmNlQ29uZmlnKSB7XG4gICAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnIHx8IHt9O1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gY29uZmlnT3JVcmwgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICAgKiBAcGFyYW0gez9PYmplY3R9IGNvbmZpZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gICAqL1xuICBhc3luYyByZXF1ZXN0KGNvbmZpZ09yVXJsLCBjb25maWcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3JlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgbGV0IGR1bW15ID0ge307XG5cbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPyBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShkdW1teSkgOiAoZHVtbXkgPSBuZXcgRXJyb3IoKSk7XG5cbiAgICAgICAgLy8gc2xpY2Ugb2ZmIHRoZSBFcnJvcjogLi4uIGxpbmVcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBkdW1teS5zdGFjayA/IGR1bW15LnN0YWNrLnJlcGxhY2UoL14uK1xcbi8sICcnKSA6ICcnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghZXJyLnN0YWNrKSB7XG4gICAgICAgICAgICBlcnIuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgICAgIC8vIG1hdGNoIHdpdGhvdXQgdGhlIDIgdG9wIHN0YWNrIGxpbmVzXG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFjayAmJiAhU3RyaW5nKGVyci5zdGFjaykuZW5kc1dpdGgoc3RhY2sucmVwbGFjZSgvXi4rXFxuLitcXG4vLCAnJykpKSB7XG4gICAgICAgICAgICBlcnIuc3RhY2sgKz0gJ1xcbicgKyBzdGFja1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlnbm9yZSB0aGUgY2FzZSB3aGVyZSBcInN0YWNrXCIgaXMgYW4gdW4td3JpdGFibGUgcHJvcGVydHlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgX3JlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgICBpZiAodHlwZW9mIGNvbmZpZ09yVXJsID09PSAnc3RyaW5nJykge1xuICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgY29uZmlnLnVybCA9IGNvbmZpZ09yVXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWcgPSBjb25maWdPclVybCB8fCB7fTtcbiAgICB9XG5cbiAgICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gICAgY29uc3Qge3RyYW5zaXRpb25hbCwgcGFyYW1zU2VyaWFsaXplciwgaGVhZGVyc30gPSBjb25maWc7XG5cbiAgICBpZiAodHJhbnNpdGlvbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHRyYW5zaXRpb25hbCwge1xuICAgICAgICBzaWxlbnRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgICAgZm9yY2VkSlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiksXG4gICAgICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbilcbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zU2VyaWFsaXplciAhPSBudWxsKSB7XG4gICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihwYXJhbXNTZXJpYWxpemVyKSkge1xuICAgICAgICBjb25maWcucGFyYW1zU2VyaWFsaXplciA9IHtcbiAgICAgICAgICBzZXJpYWxpemU6IHBhcmFtc1NlcmlhbGl6ZXJcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnMocGFyYW1zU2VyaWFsaXplciwge1xuICAgICAgICAgIGVuY29kZTogdmFsaWRhdG9ycy5mdW5jdGlvbixcbiAgICAgICAgICBzZXJpYWxpemU6IHZhbGlkYXRvcnMuZnVuY3Rpb25cbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IGNvbmZpZy5hbGxvd0Fic29sdXRlVXJsc1xuICAgIGlmIChjb25maWcuYWxsb3dBYnNvbHV0ZVVybHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH0gZWxzZSBpZiAodGhpcy5kZWZhdWx0cy5hbGxvd0Fic29sdXRlVXJscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25maWcuYWxsb3dBYnNvbHV0ZVVybHMgPSB0aGlzLmRlZmF1bHRzLmFsbG93QWJzb2x1dGVVcmxzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWcuYWxsb3dBYnNvbHV0ZVVybHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKGNvbmZpZywge1xuICAgICAgYmFzZVVybDogdmFsaWRhdG9ycy5zcGVsbGluZygnYmFzZVVSTCcpLFxuICAgICAgd2l0aFhzcmZUb2tlbjogdmFsaWRhdG9ycy5zcGVsbGluZygnd2l0aFhTUkZUb2tlbicpXG4gICAgfSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgY29uZmlnLm1ldGhvZFxuICAgIGNvbmZpZy5tZXRob2QgPSAoY29uZmlnLm1ldGhvZCB8fCB0aGlzLmRlZmF1bHRzLm1ldGhvZCB8fCAnZ2V0JykudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICAgIGxldCBjb250ZXh0SGVhZGVycyA9IGhlYWRlcnMgJiYgdXRpbHMubWVyZ2UoXG4gICAgICBoZWFkZXJzLmNvbW1vbixcbiAgICAgIGhlYWRlcnNbY29uZmlnLm1ldGhvZF1cbiAgICApO1xuXG4gICAgaGVhZGVycyAmJiB1dGlscy5mb3JFYWNoKFxuICAgICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgICAobWV0aG9kKSA9PiB7XG4gICAgICAgIGRlbGV0ZSBoZWFkZXJzW21ldGhvZF07XG4gICAgICB9XG4gICAgKTtcblxuICAgIGNvbmZpZy5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmNvbmNhdChjb250ZXh0SGVhZGVycywgaGVhZGVycyk7XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHNraXBwZWQgaW50ZXJjZXB0b3JzXG4gICAgY29uc3QgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgICBsZXQgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gdHJ1ZTtcbiAgICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICAgIGlmICh0eXBlb2YgaW50ZXJjZXB0b3IucnVuV2hlbiA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnRlcmNlcHRvci5ydW5XaGVuKGNvbmZpZykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzICYmIGludGVyY2VwdG9yLnN5bmNocm9ub3VzO1xuXG4gICAgICByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluID0gW107XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICAgIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICAgIH0pO1xuXG4gICAgbGV0IHByb21pc2U7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBsZW47XG5cbiAgICBpZiAoIXN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycykge1xuICAgICAgY29uc3QgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LmJpbmQodGhpcyksIHVuZGVmaW5lZF07XG4gICAgICBjaGFpbi51bnNoaWZ0KC4uLnJlcXVlc3RJbnRlcmNlcHRvckNoYWluKTtcbiAgICAgIGNoYWluLnB1c2goLi4ucmVzcG9uc2VJbnRlcmNlcHRvckNoYWluKTtcbiAgICAgIGxlbiA9IGNoYWluLmxlbmd0aDtcblxuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluW2krK10sIGNoYWluW2krK10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG5cbiAgICBsZW4gPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5sZW5ndGg7XG5cbiAgICBsZXQgbmV3Q29uZmlnID0gY29uZmlnO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGNvbnN0IG9uRnVsZmlsbGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW5baSsrXTtcbiAgICAgIGNvbnN0IG9uUmVqZWN0ZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbltpKytdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3Q29uZmlnID0gb25GdWxmaWxsZWQobmV3Q29uZmlnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIG9uUmVqZWN0ZWQuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBwcm9taXNlID0gZGlzcGF0Y2hSZXF1ZXN0LmNhbGwodGhpcywgbmV3Q29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBpID0gMDtcbiAgICBsZW4gPSByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4ocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluW2krK10sIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbltpKytdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGdldFVyaShjb25maWcpIHtcbiAgICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCwgY29uZmlnLmFsbG93QWJzb2x1dGVVcmxzKTtcbiAgICByZXR1cm4gYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKTtcbiAgfVxufVxuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybCxcbiAgICAgIGRhdGE6IChjb25maWcgfHwge30pLmRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUhUVFBNZXRob2QoaXNGb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGh0dHBNZXRob2QodXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgaGVhZGVyczogaXNGb3JtID8ge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSdcbiAgICAgICAgfSA6IHt9LFxuICAgICAgICB1cmwsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pKTtcbiAgICB9O1xuICB9XG5cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBnZW5lcmF0ZUhUVFBNZXRob2QoKTtcblxuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kICsgJ0Zvcm0nXSA9IGdlbmVyYXRlSFRUUE1ldGhvZCh0cnVlKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBBeGlvcztcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBDYW5jZWxlZEVycm9yIGZyb20gJy4vQ2FuY2VsZWRFcnJvci5qcyc7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKlxuICogQHJldHVybnMge0NhbmNlbFRva2VufVxuICovXG5jbGFzcyBDYW5jZWxUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKGV4ZWN1dG9yKSB7XG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGxldCByZXNvbHZlUHJvbWlzZTtcblxuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0b2tlbiA9IHRoaXM7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIHRoaXMucHJvbWlzZS50aGVuKGNhbmNlbCA9PiB7XG4gICAgICBpZiAoIXRva2VuLl9saXN0ZW5lcnMpIHJldHVybjtcblxuICAgICAgbGV0IGkgPSB0b2tlbi5fbGlzdGVuZXJzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgdG9rZW4uX2xpc3RlbmVyc1tpXShjYW5jZWwpO1xuICAgICAgfVxuICAgICAgdG9rZW4uX2xpc3RlbmVycyA9IG51bGw7XG4gICAgfSk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIHRoaXMucHJvbWlzZS50aGVuID0gb25mdWxmaWxsZWQgPT4ge1xuICAgICAgbGV0IF9yZXNvbHZlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgdG9rZW4uc3Vic2NyaWJlKHJlc29sdmUpO1xuICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB9KS50aGVuKG9uZnVsZmlsbGVkKTtcblxuICAgICAgcHJvbWlzZS5jYW5jZWwgPSBmdW5jdGlvbiByZWplY3QoKSB7XG4gICAgICAgIHRva2VuLnVuc3Vic2NyaWJlKF9yZXNvbHZlKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSwgY29uZmlnLCByZXF1ZXN0KSB7XG4gICAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWxlZEVycm9yKG1lc3NhZ2UsIGNvbmZpZywgcmVxdWVzdCk7XG4gICAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRocm93cyBhIGBDYW5jZWxlZEVycm9yYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICAgKi9cbiAgdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgIHRocm93IHRoaXMucmVhc29uO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gdGhlIGNhbmNlbCBzaWduYWxcbiAgICovXG5cbiAgc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICBsaXN0ZW5lcih0aGlzLnJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycykge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbbGlzdGVuZXJdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSBmcm9tIHRoZSBjYW5jZWwgc2lnbmFsXG4gICAqL1xuXG4gIHVuc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKCF0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG5cbiAgdG9BYm9ydFNpZ25hbCgpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXG4gICAgY29uc3QgYWJvcnQgPSAoZXJyKSA9PiB7XG4gICAgICBjb250cm9sbGVyLmFib3J0KGVycik7XG4gICAgfTtcblxuICAgIHRoaXMuc3Vic2NyaWJlKGFib3J0KTtcblxuICAgIGNvbnRyb2xsZXIuc2lnbmFsLnVuc3Vic2NyaWJlID0gKCkgPT4gdGhpcy51bnN1YnNjcmliZShhYm9ydCk7XG5cbiAgICByZXR1cm4gY29udHJvbGxlci5zaWduYWw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICAgKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICAgKi9cbiAgc3RhdGljIHNvdXJjZSgpIHtcbiAgICBsZXQgY2FuY2VsO1xuICAgIGNvbnN0IHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICAgIGNhbmNlbCA9IGM7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuLFxuICAgICAgY2FuY2VsXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYW5jZWxUb2tlbjtcbiIsICIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3NcbiAqXG4gKiBAcGFyYW0geyp9IHBheWxvYWQgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3MsIG90aGVyd2lzZSBmYWxzZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xuICByZXR1cm4gdXRpbHMuaXNPYmplY3QocGF5bG9hZCkgJiYgKHBheWxvYWQuaXNBeGlvc0Vycm9yID09PSB0cnVlKTtcbn1cbiIsICJjb25zdCBIdHRwU3RhdHVzQ29kZSA9IHtcbiAgQ29udGludWU6IDEwMCxcbiAgU3dpdGNoaW5nUHJvdG9jb2xzOiAxMDEsXG4gIFByb2Nlc3Npbmc6IDEwMixcbiAgRWFybHlIaW50czogMTAzLFxuICBPazogMjAwLFxuICBDcmVhdGVkOiAyMDEsXG4gIEFjY2VwdGVkOiAyMDIsXG4gIE5vbkF1dGhvcml0YXRpdmVJbmZvcm1hdGlvbjogMjAzLFxuICBOb0NvbnRlbnQ6IDIwNCxcbiAgUmVzZXRDb250ZW50OiAyMDUsXG4gIFBhcnRpYWxDb250ZW50OiAyMDYsXG4gIE11bHRpU3RhdHVzOiAyMDcsXG4gIEFscmVhZHlSZXBvcnRlZDogMjA4LFxuICBJbVVzZWQ6IDIyNixcbiAgTXVsdGlwbGVDaG9pY2VzOiAzMDAsXG4gIE1vdmVkUGVybWFuZW50bHk6IDMwMSxcbiAgRm91bmQ6IDMwMixcbiAgU2VlT3RoZXI6IDMwMyxcbiAgTm90TW9kaWZpZWQ6IDMwNCxcbiAgVXNlUHJveHk6IDMwNSxcbiAgVW51c2VkOiAzMDYsXG4gIFRlbXBvcmFyeVJlZGlyZWN0OiAzMDcsXG4gIFBlcm1hbmVudFJlZGlyZWN0OiAzMDgsXG4gIEJhZFJlcXVlc3Q6IDQwMCxcbiAgVW5hdXRob3JpemVkOiA0MDEsXG4gIFBheW1lbnRSZXF1aXJlZDogNDAyLFxuICBGb3JiaWRkZW46IDQwMyxcbiAgTm90Rm91bmQ6IDQwNCxcbiAgTWV0aG9kTm90QWxsb3dlZDogNDA1LFxuICBOb3RBY2NlcHRhYmxlOiA0MDYsXG4gIFByb3h5QXV0aGVudGljYXRpb25SZXF1aXJlZDogNDA3LFxuICBSZXF1ZXN0VGltZW91dDogNDA4LFxuICBDb25mbGljdDogNDA5LFxuICBHb25lOiA0MTAsXG4gIExlbmd0aFJlcXVpcmVkOiA0MTEsXG4gIFByZWNvbmRpdGlvbkZhaWxlZDogNDEyLFxuICBQYXlsb2FkVG9vTGFyZ2U6IDQxMyxcbiAgVXJpVG9vTG9uZzogNDE0LFxuICBVbnN1cHBvcnRlZE1lZGlhVHlwZTogNDE1LFxuICBSYW5nZU5vdFNhdGlzZmlhYmxlOiA0MTYsXG4gIEV4cGVjdGF0aW9uRmFpbGVkOiA0MTcsXG4gIEltQVRlYXBvdDogNDE4LFxuICBNaXNkaXJlY3RlZFJlcXVlc3Q6IDQyMSxcbiAgVW5wcm9jZXNzYWJsZUVudGl0eTogNDIyLFxuICBMb2NrZWQ6IDQyMyxcbiAgRmFpbGVkRGVwZW5kZW5jeTogNDI0LFxuICBUb29FYXJseTogNDI1LFxuICBVcGdyYWRlUmVxdWlyZWQ6IDQyNixcbiAgUHJlY29uZGl0aW9uUmVxdWlyZWQ6IDQyOCxcbiAgVG9vTWFueVJlcXVlc3RzOiA0MjksXG4gIFJlcXVlc3RIZWFkZXJGaWVsZHNUb29MYXJnZTogNDMxLFxuICBVbmF2YWlsYWJsZUZvckxlZ2FsUmVhc29uczogNDUxLFxuICBJbnRlcm5hbFNlcnZlckVycm9yOiA1MDAsXG4gIE5vdEltcGxlbWVudGVkOiA1MDEsXG4gIEJhZEdhdGV3YXk6IDUwMixcbiAgU2VydmljZVVuYXZhaWxhYmxlOiA1MDMsXG4gIEdhdGV3YXlUaW1lb3V0OiA1MDQsXG4gIEh0dHBWZXJzaW9uTm90U3VwcG9ydGVkOiA1MDUsXG4gIFZhcmlhbnRBbHNvTmVnb3RpYXRlczogNTA2LFxuICBJbnN1ZmZpY2llbnRTdG9yYWdlOiA1MDcsXG4gIExvb3BEZXRlY3RlZDogNTA4LFxuICBOb3RFeHRlbmRlZDogNTEwLFxuICBOZXR3b3JrQXV0aGVudGljYXRpb25SZXF1aXJlZDogNTExLFxuICBXZWJTZXJ2ZXJJc0Rvd246IDUyMSxcbiAgQ29ubmVjdGlvblRpbWVkT3V0OiA1MjIsXG4gIE9yaWdpbklzVW5yZWFjaGFibGU6IDUyMyxcbiAgVGltZW91dE9jY3VycmVkOiA1MjQsXG4gIFNzbEhhbmRzaGFrZUZhaWxlZDogNTI1LFxuICBJbnZhbGlkU3NsQ2VydGlmaWNhdGU6IDUyNixcbn07XG5cbk9iamVjdC5lbnRyaWVzKEh0dHBTdGF0dXNDb2RlKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgSHR0cFN0YXR1c0NvZGVbdmFsdWVdID0ga2V5O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEh0dHBTdGF0dXNDb2RlO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IGJpbmQgZnJvbSAnLi9oZWxwZXJzL2JpbmQuanMnO1xuaW1wb3J0IEF4aW9zIGZyb20gJy4vY29yZS9BeGlvcy5qcyc7XG5pbXBvcnQgbWVyZ2VDb25maWcgZnJvbSAnLi9jb3JlL21lcmdlQ29uZmlnLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2RlZmF1bHRzL2luZGV4LmpzJztcbmltcG9ydCBmb3JtRGF0YVRvSlNPTiBmcm9tICcuL2hlbHBlcnMvZm9ybURhdGFUb0pTT04uanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyc7XG5pbXBvcnQgQ2FuY2VsVG9rZW4gZnJvbSAnLi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMnO1xuaW1wb3J0IGlzQ2FuY2VsIGZyb20gJy4vY2FuY2VsL2lzQ2FuY2VsLmpzJztcbmltcG9ydCB7VkVSU0lPTn0gZnJvbSAnLi9lbnYvZGF0YS5qcyc7XG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuL2hlbHBlcnMvdG9Gb3JtRGF0YS5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgc3ByZWFkIGZyb20gJy4vaGVscGVycy9zcHJlYWQuanMnO1xuaW1wb3J0IGlzQXhpb3NFcnJvciBmcm9tICcuL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSBcIi4vY29yZS9BeGlvc0hlYWRlcnMuanNcIjtcbmltcG9ydCBhZGFwdGVycyBmcm9tICcuL2FkYXB0ZXJzL2FkYXB0ZXJzLmpzJztcbmltcG9ydCBIdHRwU3RhdHVzQ29kZSBmcm9tICcuL2hlbHBlcnMvSHR0cFN0YXR1c0NvZGUuanMnO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKlxuICogQHJldHVybnMge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIGNvbnN0IGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQsIHthbGxPd25LZXlzOiB0cnVlfSk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCwgbnVsbCwge2FsbE93bktleXM6IHRydWV9KTtcblxuICAvLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG4gIGluc3RhbmNlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICAgIHJldHVybiBjcmVhdGVJbnN0YW5jZShtZXJnZUNvbmZpZyhkZWZhdWx0Q29uZmlnLCBpbnN0YW5jZUNvbmZpZykpO1xuICB9O1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG5jb25zdCBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbGVkRXJyb3IgPSBDYW5jZWxlZEVycm9yO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSBDYW5jZWxUb2tlbjtcbmF4aW9zLmlzQ2FuY2VsID0gaXNDYW5jZWw7XG5heGlvcy5WRVJTSU9OID0gVkVSU0lPTjtcbmF4aW9zLnRvRm9ybURhdGEgPSB0b0Zvcm1EYXRhO1xuXG4vLyBFeHBvc2UgQXhpb3NFcnJvciBjbGFzc1xuYXhpb3MuQXhpb3NFcnJvciA9IEF4aW9zRXJyb3I7XG5cbi8vIGFsaWFzIGZvciBDYW5jZWxlZEVycm9yIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5heGlvcy5DYW5jZWwgPSBheGlvcy5DYW5jZWxlZEVycm9yO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuXG5heGlvcy5zcHJlYWQgPSBzcHJlYWQ7XG5cbi8vIEV4cG9zZSBpc0F4aW9zRXJyb3JcbmF4aW9zLmlzQXhpb3NFcnJvciA9IGlzQXhpb3NFcnJvcjtcblxuLy8gRXhwb3NlIG1lcmdlQ29uZmlnXG5heGlvcy5tZXJnZUNvbmZpZyA9IG1lcmdlQ29uZmlnO1xuXG5heGlvcy5BeGlvc0hlYWRlcnMgPSBBeGlvc0hlYWRlcnM7XG5cbmF4aW9zLmZvcm1Ub0pTT04gPSB0aGluZyA9PiBmb3JtRGF0YVRvSlNPTih1dGlscy5pc0hUTUxGb3JtKHRoaW5nKSA/IG5ldyBGb3JtRGF0YSh0aGluZykgOiB0aGluZyk7XG5cbmF4aW9zLmdldEFkYXB0ZXIgPSBhZGFwdGVycy5nZXRBZGFwdGVyO1xuXG5heGlvcy5IdHRwU3RhdHVzQ29kZSA9IEh0dHBTdGF0dXNDb2RlO1xuXG5heGlvcy5kZWZhdWx0ID0gYXhpb3M7XG5cbi8vIHRoaXMgbW9kdWxlIHNob3VsZCBvbmx5IGhhdmUgYSBkZWZhdWx0IGV4cG9ydFxuZXhwb3J0IGRlZmF1bHQgYXhpb3NcbiIsICJpbXBvcnQgYXhpb3MgZnJvbSAnLi9saWIvYXhpb3MuanMnO1xuXG4vLyBUaGlzIG1vZHVsZSBpcyBpbnRlbmRlZCB0byB1bndyYXAgQXhpb3MgZGVmYXVsdCBleHBvcnQgYXMgbmFtZWQuXG4vLyBLZWVwIHRvcC1sZXZlbCBleHBvcnQgc2FtZSB3aXRoIHN0YXRpYyBwcm9wZXJ0aWVzXG4vLyBzbyB0aGF0IGl0IGNhbiBrZWVwIHNhbWUgd2l0aCBlcyBtb2R1bGUgb3IgY2pzXG5jb25zdCB7XG4gIEF4aW9zLFxuICBBeGlvc0Vycm9yLFxuICBDYW5jZWxlZEVycm9yLFxuICBpc0NhbmNlbCxcbiAgQ2FuY2VsVG9rZW4sXG4gIFZFUlNJT04sXG4gIGFsbCxcbiAgQ2FuY2VsLFxuICBpc0F4aW9zRXJyb3IsXG4gIHNwcmVhZCxcbiAgdG9Gb3JtRGF0YSxcbiAgQXhpb3NIZWFkZXJzLFxuICBIdHRwU3RhdHVzQ29kZSxcbiAgZm9ybVRvSlNPTixcbiAgZ2V0QWRhcHRlcixcbiAgbWVyZ2VDb25maWdcbn0gPSBheGlvcztcblxuZXhwb3J0IHtcbiAgYXhpb3MgYXMgZGVmYXVsdCxcbiAgQXhpb3MsXG4gIEF4aW9zRXJyb3IsXG4gIENhbmNlbGVkRXJyb3IsXG4gIGlzQ2FuY2VsLFxuICBDYW5jZWxUb2tlbixcbiAgVkVSU0lPTixcbiAgYWxsLFxuICBDYW5jZWwsXG4gIGlzQXhpb3NFcnJvcixcbiAgc3ByZWFkLFxuICB0b0Zvcm1EYXRhLFxuICBBeGlvc0hlYWRlcnMsXG4gIEh0dHBTdGF0dXNDb2RlLFxuICBmb3JtVG9KU09OLFxuICBnZXRBZGFwdGVyLFxuICBtZXJnZUNvbmZpZ1xufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBc0c7OztBQ1N2RixTQUFSLEtBQXNCLElBQUksU0FBUztBQUN4QyxTQUFPLFNBQVMsT0FBTztB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QUFpQixZQUFZLENBQUM7QUFBRyxTQUFLLFVBQVUsRUFBRSxNQUFLLHdCQUFxQixhQUFhLENBQUM7QUFBRyxRQUFHLEtBQUssT0FBTyxpQkFBaUIsR0FBRTtBQUFFLFlBQU0sSUFBRSxLQUFLLE9BQU8saUJBQWlCO0FBQUcsU0FBRyxVQUFVLEVBQUUsS0FBSSwyQkFBMkIsTUFBSyxTQUFTLEVBQUUsb0JBQW9CLEVBQUUsbUJBQW1CLEVBQUUseUJBQXlCLElBQUksS0FBSyxFQUFFLEVBQUUsRUFBRSxtQkFBbUIsS0FBSyxDQUFDO0FBQUEsSUFBRztBQUFBLEVBQUU7QUFDLzREO0FBRUEsSUFBTSxZQUFOLGNBQXdCLHNCQUFNO0FBQUEsRUFBRSxTQUFRO0FBQUUsVUFBTSxFQUFFLFVBQVUsSUFBRTtBQUFNLGNBQVUsTUFBTTtBQUFHLGNBQVUsU0FBUyxNQUFLLEVBQUUsTUFBSyxzQkFBc0IsQ0FBQztBQUFHLGNBQVUsU0FBUyxLQUFJLEVBQUUsTUFBSyw0RkFBeUYsQ0FBQztBQUFHLGNBQVUsU0FBUyxLQUFJLEVBQUUsTUFBSyx3SEFBK0csQ0FBQztBQUFHLGNBQVUsU0FBUyxLQUFJLEVBQUUsTUFBSyw0RkFBc0YsQ0FBQztBQUFHLGNBQVUsU0FBUyxLQUFJLEVBQUUsTUFBSyw0REFBeUQsQ0FBQztBQUFBLEVBQUc7QUFBRTsiLAogICJuYW1lcyI6IFsicHJvdG90eXBlIiwgImRlc2NyaXB0b3JzIiwgImZpbHRlciIsICJoYXNPd25Qcm9wZXJ0eSIsICJmaWx0ZXIiLCAicGF0aCIsICJwcm90b3R5cGUiLCAidG9TdHJpbmciLCAiZW5jb2RlIiwgInBhdGgiLCAicGF0aCIsICJpc0Zvcm1EYXRhIiwgImlzRmlsZUxpc3QiLCAidHJhbnNpdGlvbmFsIiwgImZpbHRlciIsICJzZWxmIiwgInByb3RvdHlwZSIsICJ2YWxpZGF0ZVN0YXR1cyIsICJvcmlnaW4iLCAicGF0aCIsICJtZXJnZSIsICJ0cmFuc2l0aW9uYWwiLCAic2lnbmFsIiwgIml0ZXJhdG9yIiwgImRvbmUiLCAiaXNGdW5jdGlvbiIsICJSZWFkYWJsZVN0cmVhbSIsICJmZXRjaCIsICJhZGFwdGVyIiwgImFkYXB0ZXIiLCAidmFsaWRhdG9ycyIsICJ0cmFuc2l0aW9uYWwiLCAiQXhpb3MiLCAiQXhpb3NFcnJvciIsICJDYW5jZWxlZEVycm9yIiwgImlzQ2FuY2VsIiwgIkNhbmNlbFRva2VuIiwgIlZFUlNJT04iLCAiYWxsIiwgImlzQXhpb3NFcnJvciIsICJzcHJlYWQiLCAidG9Gb3JtRGF0YSIsICJBeGlvc0hlYWRlcnMiLCAiSHR0cFN0YXR1c0NvZGUiLCAiZ2V0QWRhcHRlciIsICJtZXJnZUNvbmZpZyIsICJkZWZhdWx0cyJdCn0K
